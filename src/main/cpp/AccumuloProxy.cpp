/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "AccumuloProxy.h"

namespace accumulo {

uint32_t AccumuloProxy_login_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal);
          this->__isset.principal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->loginProperties.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _ktype126;
            ::apache::thrift::protocol::TType _vtype127;
            xfer += iprot->readMapBegin(_ktype126, _vtype127, _size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              std::string _key130;
              xfer += iprot->readString(_key130);
              std::string& _val131 = this->loginProperties[_key130];
              xfer += iprot->readString(_val131);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.loginProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_login_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_login_args");

  xfer += oprot->writeFieldBegin("principal", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loginProperties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->loginProperties.size()));
    std::map<std::string, std::string> ::const_iterator _iter132;
    for (_iter132 = this->loginProperties.begin(); _iter132 != this->loginProperties.end(); ++_iter132)
    {
      xfer += oprot->writeString(_iter132->first);
      xfer += oprot->writeString(_iter132->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_login_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_login_pargs");

  xfer += oprot->writeFieldBegin("principal", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->principal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loginProperties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->loginProperties)).size()));
    std::map<std::string, std::string> ::const_iterator _iter133;
    for (_iter133 = (*(this->loginProperties)).begin(); _iter133 != (*(this->loginProperties)).end(); ++_iter133)
    {
      xfer += oprot->writeString(_iter133->first);
      xfer += oprot->writeString(_iter133->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_login_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_login_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_login_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_login_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_addConstraint_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->constraintClassName);
          this->__isset.constraintClassName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_addConstraint_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_addConstraint_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraintClassName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->constraintClassName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_addConstraint_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_addConstraint_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraintClassName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->constraintClassName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_addConstraint_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_addConstraint_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_addConstraint_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_addConstraint_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_addSplits_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->splits.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readSetBegin(_etype137, _size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              std::string _elem139;
              xfer += iprot->readBinary(_elem139);
              this->splits.insert(_elem139);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.splits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_addSplits_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_addSplits_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splits", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->splits.size()));
    std::set<std::string> ::const_iterator _iter140;
    for (_iter140 = this->splits.begin(); _iter140 != this->splits.end(); ++_iter140)
    {
      xfer += oprot->writeBinary((*_iter140));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_addSplits_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_addSplits_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splits", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->splits)).size()));
    std::set<std::string> ::const_iterator _iter141;
    for (_iter141 = (*(this->splits)).begin(); _iter141 != (*(this->splits)).end(); ++_iter141)
    {
      xfer += oprot->writeBinary((*_iter141));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_addSplits_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_addSplits_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_addSplits_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_addSplits_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_attachIterator_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->setting.read(iprot);
          this->__isset.setting = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->scopes.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readSetBegin(_etype145, _size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              IteratorScope::type _elem147;
              int32_t ecast148;
              xfer += iprot->readI32(ecast148);
              _elem147 = (IteratorScope::type)ecast148;
              this->scopes.insert(_elem147);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.scopes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_attachIterator_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_attachIterator_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setting", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->setting.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopes", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->scopes.size()));
    std::set<IteratorScope::type> ::const_iterator _iter149;
    for (_iter149 = this->scopes.begin(); _iter149 != this->scopes.end(); ++_iter149)
    {
      xfer += oprot->writeI32((int32_t)(*_iter149));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_attachIterator_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_attachIterator_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setting", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->setting)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopes", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->scopes)).size()));
    std::set<IteratorScope::type> ::const_iterator _iter150;
    for (_iter150 = (*(this->scopes)).begin(); _iter150 != (*(this->scopes)).end(); ++_iter150)
    {
      xfer += oprot->writeI32((int32_t)(*_iter150));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_attachIterator_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_attachIterator_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_attachIterator_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_attachIterator_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_checkIteratorConflicts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->setting.read(iprot);
          this->__isset.setting = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->scopes.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readSetBegin(_etype154, _size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              IteratorScope::type _elem156;
              int32_t ecast157;
              xfer += iprot->readI32(ecast157);
              _elem156 = (IteratorScope::type)ecast157;
              this->scopes.insert(_elem156);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.scopes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_checkIteratorConflicts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_checkIteratorConflicts_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setting", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->setting.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopes", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->scopes.size()));
    std::set<IteratorScope::type> ::const_iterator _iter158;
    for (_iter158 = this->scopes.begin(); _iter158 != this->scopes.end(); ++_iter158)
    {
      xfer += oprot->writeI32((int32_t)(*_iter158));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_checkIteratorConflicts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_checkIteratorConflicts_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setting", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->setting)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopes", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->scopes)).size()));
    std::set<IteratorScope::type> ::const_iterator _iter159;
    for (_iter159 = (*(this->scopes)).begin(); _iter159 != (*(this->scopes)).end(); ++_iter159)
    {
      xfer += oprot->writeI32((int32_t)(*_iter159));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_checkIteratorConflicts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_checkIteratorConflicts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_checkIteratorConflicts_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_checkIteratorConflicts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_clearLocatorCache_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_clearLocatorCache_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_clearLocatorCache_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_clearLocatorCache_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_clearLocatorCache_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_clearLocatorCache_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_clearLocatorCache_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_clearLocatorCache_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_clearLocatorCache_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_cloneTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newTableName);
          this->__isset.newTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->flush);
          this->__isset.flush = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propertiesToSet.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _ktype161;
            ::apache::thrift::protocol::TType _vtype162;
            xfer += iprot->readMapBegin(_ktype161, _vtype162, _size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              std::string _key165;
              xfer += iprot->readString(_key165);
              std::string& _val166 = this->propertiesToSet[_key165];
              xfer += iprot->readString(_val166);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.propertiesToSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->propertiesToExclude.clear();
            uint32_t _size167;
            ::apache::thrift::protocol::TType _etype170;
            xfer += iprot->readSetBegin(_etype170, _size167);
            uint32_t _i171;
            for (_i171 = 0; _i171 < _size167; ++_i171)
            {
              std::string _elem172;
              xfer += iprot->readString(_elem172);
              this->propertiesToExclude.insert(_elem172);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.propertiesToExclude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_cloneTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_cloneTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newTableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->newTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flush", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->flush);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propertiesToSet", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->propertiesToSet.size()));
    std::map<std::string, std::string> ::const_iterator _iter173;
    for (_iter173 = this->propertiesToSet.begin(); _iter173 != this->propertiesToSet.end(); ++_iter173)
    {
      xfer += oprot->writeString(_iter173->first);
      xfer += oprot->writeString(_iter173->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propertiesToExclude", ::apache::thrift::protocol::T_SET, 6);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->propertiesToExclude.size()));
    std::set<std::string> ::const_iterator _iter174;
    for (_iter174 = this->propertiesToExclude.begin(); _iter174 != this->propertiesToExclude.end(); ++_iter174)
    {
      xfer += oprot->writeString((*_iter174));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_cloneTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_cloneTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newTableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->newTableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flush", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->flush)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propertiesToSet", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->propertiesToSet)).size()));
    std::map<std::string, std::string> ::const_iterator _iter175;
    for (_iter175 = (*(this->propertiesToSet)).begin(); _iter175 != (*(this->propertiesToSet)).end(); ++_iter175)
    {
      xfer += oprot->writeString(_iter175->first);
      xfer += oprot->writeString(_iter175->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propertiesToExclude", ::apache::thrift::protocol::T_SET, 6);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->propertiesToExclude)).size()));
    std::set<std::string> ::const_iterator _iter176;
    for (_iter176 = (*(this->propertiesToExclude)).begin(); _iter176 != (*(this->propertiesToExclude)).end(); ++_iter176)
    {
      xfer += oprot->writeString((*_iter176));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_cloneTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_cloneTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_cloneTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch4) {
    xfer += oprot->writeFieldBegin("ouch4", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->ouch4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_cloneTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_compactTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size177;
            ::apache::thrift::protocol::TType _etype180;
            xfer += iprot->readListBegin(_etype180, _size177);
            this->iterators.resize(_size177);
            uint32_t _i181;
            for (_i181 = 0; _i181 < _size177; ++_i181)
            {
              xfer += this->iterators[_i181].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->flush);
          this->__isset.flush = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->wait);
          this->__isset.wait = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_compactTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_compactTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
    std::vector<IteratorSetting> ::const_iterator _iter182;
    for (_iter182 = this->iterators.begin(); _iter182 != this->iterators.end(); ++_iter182)
    {
      xfer += (*_iter182).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flush", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->flush);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->wait);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_compactTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_compactTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->startRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->endRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->iterators)).size()));
    std::vector<IteratorSetting> ::const_iterator _iter183;
    for (_iter183 = (*(this->iterators)).begin(); _iter183 != (*(this->iterators)).end(); ++_iter183)
    {
      xfer += (*_iter183).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flush", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool((*(this->flush)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool((*(this->wait)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_compactTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_compactTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_compactTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_compactTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_cancelCompaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_cancelCompaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_cancelCompaction_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_cancelCompaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_cancelCompaction_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_cancelCompaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_cancelCompaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_cancelCompaction_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_cancelCompaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->versioningIter);
          this->__isset.versioningIter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast184;
          xfer += iprot->readI32(ecast184);
          this->type = (TimeType::type)ecast184;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("versioningIter", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->versioningIter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("versioningIter", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->versioningIter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_createTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_deleteTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_deleteTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_deleteTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_deleteTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_deleteTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_deleteTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_deleteTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_deleteTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_deleteTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_deleteRows_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_deleteRows_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_deleteRows_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_deleteRows_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_deleteRows_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->startRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->endRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_deleteRows_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_deleteRows_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_deleteRows_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_deleteRows_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_exportTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->exportDir);
          this->__isset.exportDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_exportTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_exportTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exportDir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->exportDir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_exportTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_exportTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exportDir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->exportDir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_exportTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_exportTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_exportTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_exportTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_flushTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->wait);
          this->__isset.wait = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_flushTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_flushTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->wait);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_flushTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_flushTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->startRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->endRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->wait)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_flushTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_flushTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_flushTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_flushTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getDiskUsage_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->tables.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readSetBegin(_etype188, _size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              std::string _elem190;
              xfer += iprot->readString(_elem190);
              this->tables.insert(_elem190);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getDiskUsage_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getDiskUsage_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tables.size()));
    std::set<std::string> ::const_iterator _iter191;
    for (_iter191 = this->tables.begin(); _iter191 != this->tables.end(); ++_iter191)
    {
      xfer += oprot->writeString((*_iter191));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getDiskUsage_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getDiskUsage_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->tables)).size()));
    std::set<std::string> ::const_iterator _iter192;
    for (_iter192 = (*(this->tables)).begin(); _iter192 != (*(this->tables)).end(); ++_iter192)
    {
      xfer += oprot->writeString((*_iter192));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getDiskUsage_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _etype196;
            xfer += iprot->readListBegin(_etype196, _size193);
            this->success.resize(_size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              xfer += this->success[_i197].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getDiskUsage_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getDiskUsage_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<DiskUsage> ::const_iterator _iter198;
      for (_iter198 = this->success.begin(); _iter198 != this->success.end(); ++_iter198)
      {
        xfer += (*_iter198).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getDiskUsage_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size199;
            ::apache::thrift::protocol::TType _etype202;
            xfer += iprot->readListBegin(_etype202, _size199);
            (*(this->success)).resize(_size199);
            uint32_t _i203;
            for (_i203 = 0; _i203 < _size199; ++_i203)
            {
              xfer += (*(this->success))[_i203].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getLocalityGroups_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getLocalityGroups_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getLocalityGroups_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getLocalityGroups_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getLocalityGroups_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getLocalityGroups_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size204;
            ::apache::thrift::protocol::TType _ktype205;
            ::apache::thrift::protocol::TType _vtype206;
            xfer += iprot->readMapBegin(_ktype205, _vtype206, _size204);
            uint32_t _i208;
            for (_i208 = 0; _i208 < _size204; ++_i208)
            {
              std::string _key209;
              xfer += iprot->readString(_key209);
              std::set<std::string> & _val210 = this->success[_key209];
              {
                _val210.clear();
                uint32_t _size211;
                ::apache::thrift::protocol::TType _etype214;
                xfer += iprot->readSetBegin(_etype214, _size211);
                uint32_t _i215;
                for (_i215 = 0; _i215 < _size211; ++_i215)
                {
                  std::string _elem216;
                  xfer += iprot->readString(_elem216);
                  _val210.insert(_elem216);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getLocalityGroups_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getLocalityGroups_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::set<std::string> > ::const_iterator _iter217;
      for (_iter217 = this->success.begin(); _iter217 != this->success.end(); ++_iter217)
      {
        xfer += oprot->writeString(_iter217->first);
        {
          xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter217->second.size()));
          std::set<std::string> ::const_iterator _iter218;
          for (_iter218 = _iter217->second.begin(); _iter218 != _iter217->second.end(); ++_iter218)
          {
            xfer += oprot->writeString((*_iter218));
          }
          xfer += oprot->writeSetEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getLocalityGroups_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _ktype220;
            ::apache::thrift::protocol::TType _vtype221;
            xfer += iprot->readMapBegin(_ktype220, _vtype221, _size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              std::string _key224;
              xfer += iprot->readString(_key224);
              std::set<std::string> & _val225 = (*(this->success))[_key224];
              {
                _val225.clear();
                uint32_t _size226;
                ::apache::thrift::protocol::TType _etype229;
                xfer += iprot->readSetBegin(_etype229, _size226);
                uint32_t _i230;
                for (_i230 = 0; _i230 < _size226; ++_i230)
                {
                  std::string _elem231;
                  xfer += iprot->readString(_elem231);
                  _val225.insert(_elem231);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getIteratorSetting_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iteratorName);
          this->__isset.iteratorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast232;
          xfer += iprot->readI32(ecast232);
          this->scope = (IteratorScope::type)ecast232;
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getIteratorSetting_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getIteratorSetting_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iteratorName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->iteratorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->scope);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getIteratorSetting_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getIteratorSetting_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iteratorName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->iteratorName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->scope)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getIteratorSetting_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getIteratorSetting_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getIteratorSetting_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getIteratorSetting_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getMaxRow_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->auths.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readSetBegin(_etype236, _size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              std::string _elem238;
              xfer += iprot->readBinary(_elem238);
              this->auths.insert(_elem238);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.auths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startInclusive);
          this->__isset.startInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->endInclusive);
          this->__isset.endInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getMaxRow_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getMaxRow_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("auths", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->auths.size()));
    std::set<std::string> ::const_iterator _iter239;
    for (_iter239 = this->auths.begin(); _iter239 != this->auths.end(); ++_iter239)
    {
      xfer += oprot->writeBinary((*_iter239));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startInclusive", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->startInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endInclusive", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->endInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getMaxRow_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getMaxRow_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("auths", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->auths)).size()));
    std::set<std::string> ::const_iterator _iter240;
    for (_iter240 = (*(this->auths)).begin(); _iter240 != (*(this->auths)).end(); ++_iter240)
    {
      xfer += oprot->writeBinary((*_iter240));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->startRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startInclusive", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->startInclusive)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->endRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endInclusive", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool((*(this->endInclusive)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getMaxRow_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getMaxRow_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getMaxRow_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getMaxRow_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getTableProperties_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getTableProperties_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getTableProperties_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getTableProperties_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getTableProperties_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getTableProperties_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _ktype242;
            ::apache::thrift::protocol::TType _vtype243;
            xfer += iprot->readMapBegin(_ktype242, _vtype243, _size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              std::string _key246;
              xfer += iprot->readString(_key246);
              std::string& _val247 = this->success[_key246];
              xfer += iprot->readString(_val247);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getTableProperties_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getTableProperties_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter248;
      for (_iter248 = this->success.begin(); _iter248 != this->success.end(); ++_iter248)
      {
        xfer += oprot->writeString(_iter248->first);
        xfer += oprot->writeString(_iter248->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getTableProperties_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size249;
            ::apache::thrift::protocol::TType _ktype250;
            ::apache::thrift::protocol::TType _vtype251;
            xfer += iprot->readMapBegin(_ktype250, _vtype251, _size249);
            uint32_t _i253;
            for (_i253 = 0; _i253 < _size249; ++_i253)
            {
              std::string _key254;
              xfer += iprot->readString(_key254);
              std::string& _val255 = (*(this->success))[_key254];
              xfer += iprot->readString(_val255);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_importDirectory_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->importDir);
          this->__isset.importDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->failureDir);
          this->__isset.failureDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->setTime);
          this->__isset.setTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_importDirectory_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_importDirectory_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("importDir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->importDir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failureDir", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->failureDir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setTime", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->setTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_importDirectory_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_importDirectory_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("importDir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->importDir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failureDir", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->failureDir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setTime", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->setTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_importDirectory_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_importDirectory_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_importDirectory_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch4) {
    xfer += oprot->writeFieldBegin("ouch4", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_importDirectory_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_importTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->importDir);
          this->__isset.importDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_importTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_importTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("importDir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->importDir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_importTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_importTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("importDir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->importDir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_importTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_importTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_importTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_importTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listSplits_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSplits);
          this->__isset.maxSplits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listSplits_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listSplits_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxSplits", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->maxSplits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listSplits_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listSplits_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxSplits", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->maxSplits)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listSplits_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _etype259;
            xfer += iprot->readListBegin(_etype259, _size256);
            this->success.resize(_size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              xfer += iprot->readBinary(this->success[_i260]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listSplits_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_listSplits_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter261;
      for (_iter261 = this->success.begin(); _iter261 != this->success.end(); ++_iter261)
      {
        xfer += oprot->writeBinary((*_iter261));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listSplits_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _etype265;
            xfer += iprot->readListBegin(_etype265, _size262);
            (*(this->success)).resize(_size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              xfer += iprot->readBinary((*(this->success))[_i266]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listTables_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listTables_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listTables_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listTables_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listTables_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listTables_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readSetBegin(_etype270, _size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              std::string _elem272;
              xfer += iprot->readString(_elem272);
              this->success.insert(_elem272);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listTables_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_listTables_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::set<std::string> ::const_iterator _iter273;
      for (_iter273 = this->success.begin(); _iter273 != this->success.end(); ++_iter273)
      {
        xfer += oprot->writeString((*_iter273));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listTables_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size274;
            ::apache::thrift::protocol::TType _etype277;
            xfer += iprot->readSetBegin(_etype277, _size274);
            uint32_t _i278;
            for (_i278 = 0; _i278 < _size274; ++_i278)
            {
              std::string _elem279;
              xfer += iprot->readString(_elem279);
              (*(this->success)).insert(_elem279);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listIterators_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listIterators_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listIterators_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listIterators_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listIterators_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listIterators_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size280;
            ::apache::thrift::protocol::TType _ktype281;
            ::apache::thrift::protocol::TType _vtype282;
            xfer += iprot->readMapBegin(_ktype281, _vtype282, _size280);
            uint32_t _i284;
            for (_i284 = 0; _i284 < _size280; ++_i284)
            {
              std::string _key285;
              xfer += iprot->readString(_key285);
              std::set<IteratorScope::type> & _val286 = this->success[_key285];
              {
                _val286.clear();
                uint32_t _size287;
                ::apache::thrift::protocol::TType _etype290;
                xfer += iprot->readSetBegin(_etype290, _size287);
                uint32_t _i291;
                for (_i291 = 0; _i291 < _size287; ++_i291)
                {
                  IteratorScope::type _elem292;
                  int32_t ecast293;
                  xfer += iprot->readI32(ecast293);
                  _elem292 = (IteratorScope::type)ecast293;
                  _val286.insert(_elem292);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listIterators_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_listIterators_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::set<IteratorScope::type> > ::const_iterator _iter294;
      for (_iter294 = this->success.begin(); _iter294 != this->success.end(); ++_iter294)
      {
        xfer += oprot->writeString(_iter294->first);
        {
          xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter294->second.size()));
          std::set<IteratorScope::type> ::const_iterator _iter295;
          for (_iter295 = _iter294->second.begin(); _iter295 != _iter294->second.end(); ++_iter295)
          {
            xfer += oprot->writeI32((int32_t)(*_iter295));
          }
          xfer += oprot->writeSetEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listIterators_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size296;
            ::apache::thrift::protocol::TType _ktype297;
            ::apache::thrift::protocol::TType _vtype298;
            xfer += iprot->readMapBegin(_ktype297, _vtype298, _size296);
            uint32_t _i300;
            for (_i300 = 0; _i300 < _size296; ++_i300)
            {
              std::string _key301;
              xfer += iprot->readString(_key301);
              std::set<IteratorScope::type> & _val302 = (*(this->success))[_key301];
              {
                _val302.clear();
                uint32_t _size303;
                ::apache::thrift::protocol::TType _etype306;
                xfer += iprot->readSetBegin(_etype306, _size303);
                uint32_t _i307;
                for (_i307 = 0; _i307 < _size303; ++_i307)
                {
                  IteratorScope::type _elem308;
                  int32_t ecast309;
                  xfer += iprot->readI32(ecast309);
                  _elem308 = (IteratorScope::type)ecast309;
                  _val302.insert(_elem308);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listConstraints_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listConstraints_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listConstraints_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listConstraints_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listConstraints_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listConstraints_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size310;
            ::apache::thrift::protocol::TType _ktype311;
            ::apache::thrift::protocol::TType _vtype312;
            xfer += iprot->readMapBegin(_ktype311, _vtype312, _size310);
            uint32_t _i314;
            for (_i314 = 0; _i314 < _size310; ++_i314)
            {
              std::string _key315;
              xfer += iprot->readString(_key315);
              int32_t& _val316 = this->success[_key315];
              xfer += iprot->readI32(_val316);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listConstraints_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_listConstraints_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, int32_t> ::const_iterator _iter317;
      for (_iter317 = this->success.begin(); _iter317 != this->success.end(); ++_iter317)
      {
        xfer += oprot->writeString(_iter317->first);
        xfer += oprot->writeI32(_iter317->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listConstraints_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size318;
            ::apache::thrift::protocol::TType _ktype319;
            ::apache::thrift::protocol::TType _vtype320;
            xfer += iprot->readMapBegin(_ktype319, _vtype320, _size318);
            uint32_t _i322;
            for (_i322 = 0; _i322 < _size318; ++_i322)
            {
              std::string _key323;
              xfer += iprot->readString(_key323);
              int32_t& _val324 = (*(this->success))[_key323];
              xfer += iprot->readI32(_val324);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_mergeTablets_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_mergeTablets_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_mergeTablets_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_mergeTablets_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_mergeTablets_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->startRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->endRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_mergeTablets_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_mergeTablets_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_mergeTablets_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_mergeTablets_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_offlineTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->wait);
          this->__isset.wait = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_offlineTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_offlineTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->wait);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_offlineTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_offlineTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->wait)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_offlineTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_offlineTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_offlineTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_offlineTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_onlineTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->wait);
          this->__isset.wait = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_onlineTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_onlineTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->wait);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_onlineTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_onlineTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wait", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->wait)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_onlineTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_onlineTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_onlineTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_onlineTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeConstraint_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->constraint);
          this->__isset.constraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeConstraint_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeConstraint_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraint", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->constraint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeConstraint_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeConstraint_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraint", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->constraint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeConstraint_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeConstraint_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_removeConstraint_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeConstraint_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeIterator_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iterName);
          this->__isset.iterName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->scopes.clear();
            uint32_t _size325;
            ::apache::thrift::protocol::TType _etype328;
            xfer += iprot->readSetBegin(_etype328, _size325);
            uint32_t _i329;
            for (_i329 = 0; _i329 < _size325; ++_i329)
            {
              IteratorScope::type _elem330;
              int32_t ecast331;
              xfer += iprot->readI32(ecast331);
              _elem330 = (IteratorScope::type)ecast331;
              this->scopes.insert(_elem330);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.scopes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeIterator_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeIterator_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->iterName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopes", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->scopes.size()));
    std::set<IteratorScope::type> ::const_iterator _iter332;
    for (_iter332 = this->scopes.begin(); _iter332 != this->scopes.end(); ++_iter332)
    {
      xfer += oprot->writeI32((int32_t)(*_iter332));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeIterator_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeIterator_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->iterName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopes", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->scopes)).size()));
    std::set<IteratorScope::type> ::const_iterator _iter333;
    for (_iter333 = (*(this->scopes)).begin(); _iter333 != (*(this->scopes)).end(); ++_iter333)
    {
      xfer += oprot->writeI32((int32_t)(*_iter333));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeIterator_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeIterator_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_removeIterator_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeIterator_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeTableProperty_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->property);
          this->__isset.property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeTableProperty_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeTableProperty_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->property);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeTableProperty_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeTableProperty_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->property)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeTableProperty_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeTableProperty_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_removeTableProperty_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeTableProperty_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_renameTable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oldTableName);
          this->__isset.oldTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newTableName);
          this->__isset.newTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_renameTable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_renameTable_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oldTableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->oldTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newTableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->newTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_renameTable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_renameTable_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oldTableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->oldTableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newTableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->newTableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_renameTable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_renameTable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_renameTable_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch4) {
    xfer += oprot->writeFieldBegin("ouch4", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->ouch4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_renameTable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setLocalityGroups_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groups.clear();
            uint32_t _size334;
            ::apache::thrift::protocol::TType _ktype335;
            ::apache::thrift::protocol::TType _vtype336;
            xfer += iprot->readMapBegin(_ktype335, _vtype336, _size334);
            uint32_t _i338;
            for (_i338 = 0; _i338 < _size334; ++_i338)
            {
              std::string _key339;
              xfer += iprot->readString(_key339);
              std::set<std::string> & _val340 = this->groups[_key339];
              {
                _val340.clear();
                uint32_t _size341;
                ::apache::thrift::protocol::TType _etype344;
                xfer += iprot->readSetBegin(_etype344, _size341);
                uint32_t _i345;
                for (_i345 = 0; _i345 < _size341; ++_i345)
                {
                  std::string _elem346;
                  xfer += iprot->readString(_elem346);
                  _val340.insert(_elem346);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setLocalityGroups_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_setLocalityGroups_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->groups.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter347;
    for (_iter347 = this->groups.begin(); _iter347 != this->groups.end(); ++_iter347)
    {
      xfer += oprot->writeString(_iter347->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter347->second.size()));
        std::set<std::string> ::const_iterator _iter348;
        for (_iter348 = _iter347->second.begin(); _iter348 != _iter347->second.end(); ++_iter348)
        {
          xfer += oprot->writeString((*_iter348));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setLocalityGroups_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_setLocalityGroups_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>((*(this->groups)).size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter349;
    for (_iter349 = (*(this->groups)).begin(); _iter349 != (*(this->groups)).end(); ++_iter349)
    {
      xfer += oprot->writeString(_iter349->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter349->second.size()));
        std::set<std::string> ::const_iterator _iter350;
        for (_iter350 = _iter349->second.begin(); _iter350 != _iter349->second.end(); ++_iter350)
        {
          xfer += oprot->writeString((*_iter350));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setLocalityGroups_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setLocalityGroups_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_setLocalityGroups_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setLocalityGroups_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setTableProperty_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->property);
          this->__isset.property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setTableProperty_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_setTableProperty_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->property);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setTableProperty_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_setTableProperty_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->property)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setTableProperty_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setTableProperty_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_setTableProperty_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setTableProperty_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_splitRangeByTablets_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range.read(iprot);
          this->__isset.range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSplits);
          this->__isset.maxSplits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_splitRangeByTablets_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_splitRangeByTablets_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->range.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxSplits", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->maxSplits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_splitRangeByTablets_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_splitRangeByTablets_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->range)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxSplits", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->maxSplits)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_splitRangeByTablets_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readSetBegin(_etype354, _size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              Range _elem356;
              xfer += _elem356.read(iprot);
              this->success.insert(_elem356);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_splitRangeByTablets_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_splitRangeByTablets_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::set<Range> ::const_iterator _iter357;
      for (_iter357 = this->success.begin(); _iter357 != this->success.end(); ++_iter357)
      {
        xfer += (*_iter357).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_splitRangeByTablets_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size358;
            ::apache::thrift::protocol::TType _etype361;
            xfer += iprot->readSetBegin(_etype361, _size358);
            uint32_t _i362;
            for (_i362 = 0; _i362 < _size358; ++_i362)
            {
              Range _elem363;
              xfer += _elem363.read(iprot);
              (*(this->success)).insert(_elem363);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_tableExists_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_tableExists_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_tableExists_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_tableExists_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_tableExists_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_tableExists_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_tableExists_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_tableExists_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_tableExists_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_tableIdMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_tableIdMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_tableIdMap_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_tableIdMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_tableIdMap_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_tableIdMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size364;
            ::apache::thrift::protocol::TType _ktype365;
            ::apache::thrift::protocol::TType _vtype366;
            xfer += iprot->readMapBegin(_ktype365, _vtype366, _size364);
            uint32_t _i368;
            for (_i368 = 0; _i368 < _size364; ++_i368)
            {
              std::string _key369;
              xfer += iprot->readString(_key369);
              std::string& _val370 = this->success[_key369];
              xfer += iprot->readString(_val370);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_tableIdMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_tableIdMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter371;
      for (_iter371 = this->success.begin(); _iter371 != this->success.end(); ++_iter371)
      {
        xfer += oprot->writeString(_iter371->first);
        xfer += oprot->writeString(_iter371->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_tableIdMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size372;
            ::apache::thrift::protocol::TType _ktype373;
            ::apache::thrift::protocol::TType _vtype374;
            xfer += iprot->readMapBegin(_ktype373, _vtype374, _size372);
            uint32_t _i376;
            for (_i376 = 0; _i376 < _size372; ++_i376)
            {
              std::string _key377;
              xfer += iprot->readString(_key377);
              std::string& _val378 = (*(this->success))[_key377];
              xfer += iprot->readString(_val378);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_testTableClassLoad_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asTypeName);
          this->__isset.asTypeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_testTableClassLoad_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_testTableClassLoad_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asTypeName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->asTypeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_testTableClassLoad_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_testTableClassLoad_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->className)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asTypeName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->asTypeName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_testTableClassLoad_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_testTableClassLoad_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_testTableClassLoad_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_testTableClassLoad_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_pingTabletServer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tserver);
          this->__isset.tserver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_pingTabletServer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_pingTabletServer_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tserver", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tserver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_pingTabletServer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_pingTabletServer_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tserver", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tserver)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_pingTabletServer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_pingTabletServer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_pingTabletServer_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_pingTabletServer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getActiveScans_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tserver);
          this->__isset.tserver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getActiveScans_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getActiveScans_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tserver", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tserver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getActiveScans_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getActiveScans_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tserver", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tserver)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getActiveScans_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size379;
            ::apache::thrift::protocol::TType _etype382;
            xfer += iprot->readListBegin(_etype382, _size379);
            this->success.resize(_size379);
            uint32_t _i383;
            for (_i383 = 0; _i383 < _size379; ++_i383)
            {
              xfer += this->success[_i383].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getActiveScans_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getActiveScans_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ActiveScan> ::const_iterator _iter384;
      for (_iter384 = this->success.begin(); _iter384 != this->success.end(); ++_iter384)
      {
        xfer += (*_iter384).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getActiveScans_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size385;
            ::apache::thrift::protocol::TType _etype388;
            xfer += iprot->readListBegin(_etype388, _size385);
            (*(this->success)).resize(_size385);
            uint32_t _i389;
            for (_i389 = 0; _i389 < _size385; ++_i389)
            {
              xfer += (*(this->success))[_i389].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getActiveCompactions_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tserver);
          this->__isset.tserver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getActiveCompactions_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getActiveCompactions_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tserver", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tserver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getActiveCompactions_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getActiveCompactions_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tserver", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tserver)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getActiveCompactions_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size390;
            ::apache::thrift::protocol::TType _etype393;
            xfer += iprot->readListBegin(_etype393, _size390);
            this->success.resize(_size390);
            uint32_t _i394;
            for (_i394 = 0; _i394 < _size390; ++_i394)
            {
              xfer += this->success[_i394].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getActiveCompactions_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getActiveCompactions_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ActiveCompaction> ::const_iterator _iter395;
      for (_iter395 = this->success.begin(); _iter395 != this->success.end(); ++_iter395)
      {
        xfer += (*_iter395).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getActiveCompactions_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size396;
            ::apache::thrift::protocol::TType _etype399;
            xfer += iprot->readListBegin(_etype399, _size396);
            (*(this->success)).resize(_size396);
            uint32_t _i400;
            for (_i400 = 0; _i400 < _size396; ++_i400)
            {
              xfer += (*(this->success))[_i400].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getSiteConfiguration_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getSiteConfiguration_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getSiteConfiguration_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getSiteConfiguration_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getSiteConfiguration_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getSiteConfiguration_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size401;
            ::apache::thrift::protocol::TType _ktype402;
            ::apache::thrift::protocol::TType _vtype403;
            xfer += iprot->readMapBegin(_ktype402, _vtype403, _size401);
            uint32_t _i405;
            for (_i405 = 0; _i405 < _size401; ++_i405)
            {
              std::string _key406;
              xfer += iprot->readString(_key406);
              std::string& _val407 = this->success[_key406];
              xfer += iprot->readString(_val407);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getSiteConfiguration_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getSiteConfiguration_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter408;
      for (_iter408 = this->success.begin(); _iter408 != this->success.end(); ++_iter408)
      {
        xfer += oprot->writeString(_iter408->first);
        xfer += oprot->writeString(_iter408->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getSiteConfiguration_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size409;
            ::apache::thrift::protocol::TType _ktype410;
            ::apache::thrift::protocol::TType _vtype411;
            xfer += iprot->readMapBegin(_ktype410, _vtype411, _size409);
            uint32_t _i413;
            for (_i413 = 0; _i413 < _size409; ++_i413)
            {
              std::string _key414;
              xfer += iprot->readString(_key414);
              std::string& _val415 = (*(this->success))[_key414];
              xfer += iprot->readString(_val415);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getSystemConfiguration_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getSystemConfiguration_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getSystemConfiguration_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getSystemConfiguration_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getSystemConfiguration_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getSystemConfiguration_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size416;
            ::apache::thrift::protocol::TType _ktype417;
            ::apache::thrift::protocol::TType _vtype418;
            xfer += iprot->readMapBegin(_ktype417, _vtype418, _size416);
            uint32_t _i420;
            for (_i420 = 0; _i420 < _size416; ++_i420)
            {
              std::string _key421;
              xfer += iprot->readString(_key421);
              std::string& _val422 = this->success[_key421];
              xfer += iprot->readString(_val422);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getSystemConfiguration_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getSystemConfiguration_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter423;
      for (_iter423 = this->success.begin(); _iter423 != this->success.end(); ++_iter423)
      {
        xfer += oprot->writeString(_iter423->first);
        xfer += oprot->writeString(_iter423->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getSystemConfiguration_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size424;
            ::apache::thrift::protocol::TType _ktype425;
            ::apache::thrift::protocol::TType _vtype426;
            xfer += iprot->readMapBegin(_ktype425, _vtype426, _size424);
            uint32_t _i428;
            for (_i428 = 0; _i428 < _size424; ++_i428)
            {
              std::string _key429;
              xfer += iprot->readString(_key429);
              std::string& _val430 = (*(this->success))[_key429];
              xfer += iprot->readString(_val430);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getTabletServers_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getTabletServers_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getTabletServers_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getTabletServers_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getTabletServers_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getTabletServers_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size431;
            ::apache::thrift::protocol::TType _etype434;
            xfer += iprot->readListBegin(_etype434, _size431);
            this->success.resize(_size431);
            uint32_t _i435;
            for (_i435 = 0; _i435 < _size431; ++_i435)
            {
              xfer += iprot->readString(this->success[_i435]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getTabletServers_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getTabletServers_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter436;
      for (_iter436 = this->success.begin(); _iter436 != this->success.end(); ++_iter436)
      {
        xfer += oprot->writeString((*_iter436));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getTabletServers_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size437;
            ::apache::thrift::protocol::TType _etype440;
            xfer += iprot->readListBegin(_etype440, _size437);
            (*(this->success)).resize(_size437);
            uint32_t _i441;
            for (_i441 = 0; _i441 < _size437; ++_i441)
            {
              xfer += iprot->readString((*(this->success))[_i441]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeProperty_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->property);
          this->__isset.property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeProperty_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeProperty_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->property);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeProperty_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_removeProperty_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->property)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeProperty_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_removeProperty_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_removeProperty_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_removeProperty_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setProperty_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->property);
          this->__isset.property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setProperty_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_setProperty_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->property);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setProperty_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_setProperty_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->property)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setProperty_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_setProperty_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_setProperty_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_setProperty_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_testClassLoad_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asTypeName);
          this->__isset.asTypeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_testClassLoad_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_testClassLoad_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asTypeName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->asTypeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_testClassLoad_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_testClassLoad_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->className)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asTypeName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->asTypeName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_testClassLoad_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_testClassLoad_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_testClassLoad_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_testClassLoad_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_authenticateUser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size442;
            ::apache::thrift::protocol::TType _ktype443;
            ::apache::thrift::protocol::TType _vtype444;
            xfer += iprot->readMapBegin(_ktype443, _vtype444, _size442);
            uint32_t _i446;
            for (_i446 = 0; _i446 < _size442; ++_i446)
            {
              std::string _key447;
              xfer += iprot->readString(_key447);
              std::string& _val448 = this->properties[_key447];
              xfer += iprot->readString(_val448);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_authenticateUser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_authenticateUser_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter449;
    for (_iter449 = this->properties.begin(); _iter449 != this->properties.end(); ++_iter449)
    {
      xfer += oprot->writeString(_iter449->first);
      xfer += oprot->writeString(_iter449->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_authenticateUser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_authenticateUser_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->properties)).size()));
    std::map<std::string, std::string> ::const_iterator _iter450;
    for (_iter450 = (*(this->properties)).begin(); _iter450 != (*(this->properties)).end(); ++_iter450)
    {
      xfer += oprot->writeString(_iter450->first);
      xfer += oprot->writeString(_iter450->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_authenticateUser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_authenticateUser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_authenticateUser_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_authenticateUser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_changeUserAuthorizations_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->authorizations.clear();
            uint32_t _size451;
            ::apache::thrift::protocol::TType _etype454;
            xfer += iprot->readSetBegin(_etype454, _size451);
            uint32_t _i455;
            for (_i455 = 0; _i455 < _size451; ++_i455)
            {
              std::string _elem456;
              xfer += iprot->readBinary(_elem456);
              this->authorizations.insert(_elem456);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_changeUserAuthorizations_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_changeUserAuthorizations_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
    std::set<std::string> ::const_iterator _iter457;
    for (_iter457 = this->authorizations.begin(); _iter457 != this->authorizations.end(); ++_iter457)
    {
      xfer += oprot->writeBinary((*_iter457));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_changeUserAuthorizations_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_changeUserAuthorizations_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->authorizations)).size()));
    std::set<std::string> ::const_iterator _iter458;
    for (_iter458 = (*(this->authorizations)).begin(); _iter458 != (*(this->authorizations)).end(); ++_iter458)
    {
      xfer += oprot->writeBinary((*_iter458));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_changeUserAuthorizations_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_changeUserAuthorizations_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_changeUserAuthorizations_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_changeUserAuthorizations_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_changeLocalUserPassword_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_changeLocalUserPassword_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_changeLocalUserPassword_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_changeLocalUserPassword_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_changeLocalUserPassword_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->password)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_changeLocalUserPassword_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_changeLocalUserPassword_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_changeLocalUserPassword_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_changeLocalUserPassword_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createLocalUser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createLocalUser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createLocalUser_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createLocalUser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createLocalUser_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->password)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createLocalUser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createLocalUser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_createLocalUser_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createLocalUser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_dropLocalUser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_dropLocalUser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_dropLocalUser_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_dropLocalUser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_dropLocalUser_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_dropLocalUser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_dropLocalUser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_dropLocalUser_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_dropLocalUser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getUserAuthorizations_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getUserAuthorizations_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getUserAuthorizations_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getUserAuthorizations_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getUserAuthorizations_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getUserAuthorizations_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size459;
            ::apache::thrift::protocol::TType _etype462;
            xfer += iprot->readListBegin(_etype462, _size459);
            this->success.resize(_size459);
            uint32_t _i463;
            for (_i463 = 0; _i463 < _size459; ++_i463)
            {
              xfer += iprot->readBinary(this->success[_i463]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getUserAuthorizations_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getUserAuthorizations_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter464;
      for (_iter464 = this->success.begin(); _iter464 != this->success.end(); ++_iter464)
      {
        xfer += oprot->writeBinary((*_iter464));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getUserAuthorizations_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size465;
            ::apache::thrift::protocol::TType _etype468;
            xfer += iprot->readListBegin(_etype468, _size465);
            (*(this->success)).resize(_size465);
            uint32_t _i469;
            for (_i469 = 0; _i469 < _size465; ++_i469)
            {
              xfer += iprot->readBinary((*(this->success))[_i469]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_grantSystemPermission_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast470;
          xfer += iprot->readI32(ecast470);
          this->perm = (SystemPermission::type)ecast470;
          this->__isset.perm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_grantSystemPermission_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_grantSystemPermission_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->perm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_grantSystemPermission_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_grantSystemPermission_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->perm)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_grantSystemPermission_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_grantSystemPermission_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_grantSystemPermission_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_grantSystemPermission_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_grantTablePermission_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast471;
          xfer += iprot->readI32(ecast471);
          this->perm = (TablePermission::type)ecast471;
          this->__isset.perm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_grantTablePermission_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_grantTablePermission_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->perm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_grantTablePermission_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_grantTablePermission_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->table)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->perm)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_grantTablePermission_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_grantTablePermission_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_grantTablePermission_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_grantTablePermission_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasSystemPermission_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast472;
          xfer += iprot->readI32(ecast472);
          this->perm = (SystemPermission::type)ecast472;
          this->__isset.perm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasSystemPermission_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_hasSystemPermission_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->perm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasSystemPermission_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_hasSystemPermission_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->perm)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasSystemPermission_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasSystemPermission_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_hasSystemPermission_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasSystemPermission_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasTablePermission_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast473;
          xfer += iprot->readI32(ecast473);
          this->perm = (TablePermission::type)ecast473;
          this->__isset.perm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasTablePermission_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_hasTablePermission_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->perm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasTablePermission_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_hasTablePermission_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->table)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->perm)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasTablePermission_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasTablePermission_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_hasTablePermission_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasTablePermission_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listLocalUsers_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listLocalUsers_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listLocalUsers_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listLocalUsers_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_listLocalUsers_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listLocalUsers_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size474;
            ::apache::thrift::protocol::TType _etype477;
            xfer += iprot->readSetBegin(_etype477, _size474);
            uint32_t _i478;
            for (_i478 = 0; _i478 < _size474; ++_i478)
            {
              std::string _elem479;
              xfer += iprot->readString(_elem479);
              this->success.insert(_elem479);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_listLocalUsers_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_listLocalUsers_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::set<std::string> ::const_iterator _iter480;
      for (_iter480 = this->success.begin(); _iter480 != this->success.end(); ++_iter480)
      {
        xfer += oprot->writeString((*_iter480));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_listLocalUsers_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size481;
            ::apache::thrift::protocol::TType _etype484;
            xfer += iprot->readSetBegin(_etype484, _size481);
            uint32_t _i485;
            for (_i485 = 0; _i485 < _size481; ++_i485)
            {
              std::string _elem486;
              xfer += iprot->readString(_elem486);
              (*(this->success)).insert(_elem486);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_revokeSystemPermission_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast487;
          xfer += iprot->readI32(ecast487);
          this->perm = (SystemPermission::type)ecast487;
          this->__isset.perm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_revokeSystemPermission_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_revokeSystemPermission_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->perm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_revokeSystemPermission_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_revokeSystemPermission_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->perm)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_revokeSystemPermission_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_revokeSystemPermission_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_revokeSystemPermission_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_revokeSystemPermission_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_revokeTablePermission_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast488;
          xfer += iprot->readI32(ecast488);
          this->perm = (TablePermission::type)ecast488;
          this->__isset.perm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_revokeTablePermission_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_revokeTablePermission_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->perm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_revokeTablePermission_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_revokeTablePermission_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->user)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->table)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->perm)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_revokeTablePermission_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_revokeTablePermission_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_revokeTablePermission_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_revokeTablePermission_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createBatchScanner_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createBatchScanner_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createBatchScanner_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createBatchScanner_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createBatchScanner_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createBatchScanner_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createBatchScanner_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_createBatchScanner_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createBatchScanner_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createScanner_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createScanner_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createScanner_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createScanner_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createScanner_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createScanner_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createScanner_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_createScanner_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createScanner_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasNext_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scanner);
          this->__isset.scanner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasNext_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_hasNext_args");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->scanner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasNext_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_hasNext_pargs");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->scanner)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasNext_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_hasNext_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_hasNext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_hasNext_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_nextEntry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scanner);
          this->__isset.scanner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_nextEntry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_nextEntry_args");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->scanner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_nextEntry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_nextEntry_pargs");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->scanner)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_nextEntry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_nextEntry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_nextEntry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_nextEntry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_nextK_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scanner);
          this->__isset.scanner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->k);
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_nextK_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_nextK_args");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->scanner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->k);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_nextK_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_nextK_pargs");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->scanner)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->k)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_nextK_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_nextK_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_nextK_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_nextK_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeScanner_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scanner);
          this->__isset.scanner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeScanner_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_closeScanner_args");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->scanner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeScanner_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_closeScanner_pargs");

  xfer += oprot->writeFieldBegin("scanner", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->scanner)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeScanner_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeScanner_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_closeScanner_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeScanner_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateAndFlush_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cells.clear();
            uint32_t _size489;
            ::apache::thrift::protocol::TType _ktype490;
            ::apache::thrift::protocol::TType _vtype491;
            xfer += iprot->readMapBegin(_ktype490, _vtype491, _size489);
            uint32_t _i493;
            for (_i493 = 0; _i493 < _size489; ++_i493)
            {
              std::string _key494;
              xfer += iprot->readBinary(_key494);
              std::vector<ColumnUpdate> & _val495 = this->cells[_key494];
              {
                _val495.clear();
                uint32_t _size496;
                ::apache::thrift::protocol::TType _etype499;
                xfer += iprot->readListBegin(_etype499, _size496);
                _val495.resize(_size496);
                uint32_t _i500;
                for (_i500 = 0; _i500 < _size496; ++_i500)
                {
                  xfer += _val495[_i500].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateAndFlush_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_updateAndFlush_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cells.size()));
    std::map<std::string, std::vector<ColumnUpdate> > ::const_iterator _iter501;
    for (_iter501 = this->cells.begin(); _iter501 != this->cells.end(); ++_iter501)
    {
      xfer += oprot->writeBinary(_iter501->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter501->second.size()));
        std::vector<ColumnUpdate> ::const_iterator _iter502;
        for (_iter502 = _iter501->second.begin(); _iter502 != _iter501->second.end(); ++_iter502)
        {
          xfer += (*_iter502).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateAndFlush_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_updateAndFlush_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->cells)).size()));
    std::map<std::string, std::vector<ColumnUpdate> > ::const_iterator _iter503;
    for (_iter503 = (*(this->cells)).begin(); _iter503 != (*(this->cells)).end(); ++_iter503)
    {
      xfer += oprot->writeBinary(_iter503->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter503->second.size()));
        std::vector<ColumnUpdate> ::const_iterator _iter504;
        for (_iter504 = _iter503->second.begin(); _iter504 != _iter503->second.end(); ++_iter504)
        {
          xfer += (*_iter504).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateAndFlush_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->outch1.read(iprot);
          this->__isset.outch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateAndFlush_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_updateAndFlush_result");

  if (this->__isset.outch1) {
    xfer += oprot->writeFieldBegin("outch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->outch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch4) {
    xfer += oprot->writeFieldBegin("ouch4", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->ouch4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateAndFlush_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->outch1.read(iprot);
          this->__isset.outch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch4.read(iprot);
          this->__isset.ouch4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createWriter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->opts.read(iprot);
          this->__isset.opts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createWriter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createWriter_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("opts", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->opts.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createWriter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createWriter_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("opts", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->opts)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createWriter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->outch1.read(iprot);
          this->__isset.outch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createWriter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_createWriter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.outch1) {
    xfer += oprot->writeFieldBegin("outch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->outch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createWriter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->outch1.read(iprot);
          this->__isset.outch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_update_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->writer);
          this->__isset.writer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cells.clear();
            uint32_t _size505;
            ::apache::thrift::protocol::TType _ktype506;
            ::apache::thrift::protocol::TType _vtype507;
            xfer += iprot->readMapBegin(_ktype506, _vtype507, _size505);
            uint32_t _i509;
            for (_i509 = 0; _i509 < _size505; ++_i509)
            {
              std::string _key510;
              xfer += iprot->readBinary(_key510);
              std::vector<ColumnUpdate> & _val511 = this->cells[_key510];
              {
                _val511.clear();
                uint32_t _size512;
                ::apache::thrift::protocol::TType _etype515;
                xfer += iprot->readListBegin(_etype515, _size512);
                _val511.resize(_size512);
                uint32_t _i516;
                for (_i516 = 0; _i516 < _size512; ++_i516)
                {
                  xfer += _val511[_i516].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_update_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_update_args");

  xfer += oprot->writeFieldBegin("writer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->writer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cells.size()));
    std::map<std::string, std::vector<ColumnUpdate> > ::const_iterator _iter517;
    for (_iter517 = this->cells.begin(); _iter517 != this->cells.end(); ++_iter517)
    {
      xfer += oprot->writeBinary(_iter517->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter517->second.size()));
        std::vector<ColumnUpdate> ::const_iterator _iter518;
        for (_iter518 = _iter517->second.begin(); _iter518 != _iter517->second.end(); ++_iter518)
        {
          xfer += (*_iter518).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_update_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_update_pargs");

  xfer += oprot->writeFieldBegin("writer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->writer)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->cells)).size()));
    std::map<std::string, std::vector<ColumnUpdate> > ::const_iterator _iter519;
    for (_iter519 = (*(this->cells)).begin(); _iter519 != (*(this->cells)).end(); ++_iter519)
    {
      xfer += oprot->writeBinary(_iter519->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter519->second.size()));
        std::vector<ColumnUpdate> ::const_iterator _iter520;
        for (_iter520 = _iter519->second.begin(); _iter520 != _iter519->second.end(); ++_iter520)
        {
          xfer += (*_iter520).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_flush_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->writer);
          this->__isset.writer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_flush_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_flush_args");

  xfer += oprot->writeFieldBegin("writer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->writer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_flush_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_flush_pargs");

  xfer += oprot->writeFieldBegin("writer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->writer)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_flush_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_flush_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_flush_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_flush_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeWriter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->writer);
          this->__isset.writer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeWriter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_closeWriter_args");

  xfer += oprot->writeFieldBegin("writer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->writer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeWriter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_closeWriter_pargs");

  xfer += oprot->writeFieldBegin("writer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->writer)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeWriter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeWriter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_closeWriter_result");

  if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeWriter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateRowConditionally_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updates.read(iprot);
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateRowConditionally_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_updateRowConditionally_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->updates.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateRowConditionally_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_updateRowConditionally_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->row)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->updates)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateRowConditionally_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast521;
          xfer += iprot->readI32(ecast521);
          this->success = (ConditionalStatus::type)ecast521;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateRowConditionally_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_updateRowConditionally_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateRowConditionally_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast522;
          xfer += iprot->readI32(ecast522);
          (*(this->success)) = (ConditionalStatus::type)ecast522;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createConditionalWriter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->login);
          this->__isset.login = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createConditionalWriter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createConditionalWriter_args");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->login);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createConditionalWriter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_createConditionalWriter_pargs");

  xfer += oprot->writeFieldBegin("login", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->login)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->options)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createConditionalWriter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_createConditionalWriter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_createConditionalWriter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_createConditionalWriter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateRowsConditionally_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->conditionalWriter);
          this->__isset.conditionalWriter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->updates.clear();
            uint32_t _size523;
            ::apache::thrift::protocol::TType _ktype524;
            ::apache::thrift::protocol::TType _vtype525;
            xfer += iprot->readMapBegin(_ktype524, _vtype525, _size523);
            uint32_t _i527;
            for (_i527 = 0; _i527 < _size523; ++_i527)
            {
              std::string _key528;
              xfer += iprot->readBinary(_key528);
              ConditionalUpdates& _val529 = this->updates[_key528];
              xfer += _val529.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateRowsConditionally_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_updateRowsConditionally_args");

  xfer += oprot->writeFieldBegin("conditionalWriter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->conditionalWriter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
    std::map<std::string, ConditionalUpdates> ::const_iterator _iter530;
    for (_iter530 = this->updates.begin(); _iter530 != this->updates.end(); ++_iter530)
    {
      xfer += oprot->writeBinary(_iter530->first);
      xfer += _iter530->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateRowsConditionally_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_updateRowsConditionally_pargs");

  xfer += oprot->writeFieldBegin("conditionalWriter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->conditionalWriter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->updates)).size()));
    std::map<std::string, ConditionalUpdates> ::const_iterator _iter531;
    for (_iter531 = (*(this->updates)).begin(); _iter531 != (*(this->updates)).end(); ++_iter531)
    {
      xfer += oprot->writeBinary(_iter531->first);
      xfer += _iter531->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateRowsConditionally_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size532;
            ::apache::thrift::protocol::TType _ktype533;
            ::apache::thrift::protocol::TType _vtype534;
            xfer += iprot->readMapBegin(_ktype533, _vtype534, _size532);
            uint32_t _i536;
            for (_i536 = 0; _i536 < _size532; ++_i536)
            {
              std::string _key537;
              xfer += iprot->readBinary(_key537);
              ConditionalStatus::type& _val538 = this->success[_key537];
              int32_t ecast539;
              xfer += iprot->readI32(ecast539);
              _val538 = (ConditionalStatus::type)ecast539;
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_updateRowsConditionally_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_updateRowsConditionally_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, ConditionalStatus::type> ::const_iterator _iter540;
      for (_iter540 = this->success.begin(); _iter540 != this->success.end(); ++_iter540)
      {
        xfer += oprot->writeBinary(_iter540->first);
        xfer += oprot->writeI32((int32_t)_iter540->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch1) {
    xfer += oprot->writeFieldBegin("ouch1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch2) {
    xfer += oprot->writeFieldBegin("ouch2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ouch2.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch3) {
    xfer += oprot->writeFieldBegin("ouch3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ouch3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_updateRowsConditionally_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size541;
            ::apache::thrift::protocol::TType _ktype542;
            ::apache::thrift::protocol::TType _vtype543;
            xfer += iprot->readMapBegin(_ktype542, _vtype543, _size541);
            uint32_t _i545;
            for (_i545 = 0; _i545 < _size541; ++_i545)
            {
              std::string _key546;
              xfer += iprot->readBinary(_key546);
              ConditionalStatus::type& _val547 = (*(this->success))[_key546];
              int32_t ecast548;
              xfer += iprot->readI32(ecast548);
              _val547 = (ConditionalStatus::type)ecast548;
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch1.read(iprot);
          this->__isset.ouch1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch2.read(iprot);
          this->__isset.ouch2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch3.read(iprot);
          this->__isset.ouch3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeConditionalWriter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->conditionalWriter);
          this->__isset.conditionalWriter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeConditionalWriter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_closeConditionalWriter_args");

  xfer += oprot->writeFieldBegin("conditionalWriter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->conditionalWriter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeConditionalWriter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_closeConditionalWriter_pargs");

  xfer += oprot->writeFieldBegin("conditionalWriter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->conditionalWriter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeConditionalWriter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_closeConditionalWriter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_closeConditionalWriter_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_closeConditionalWriter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getRowRange_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getRowRange_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getRowRange_args");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getRowRange_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getRowRange_pargs");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->row)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getRowRange_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getRowRange_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getRowRange_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getRowRange_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getFollowing_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast549;
          xfer += iprot->readI32(ecast549);
          this->part = (PartialKey::type)ecast549;
          this->__isset.part = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getFollowing_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getFollowing_args");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("part", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->part);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getFollowing_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloProxy_getFollowing_pargs");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->key)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("part", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->part)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getFollowing_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloProxy_getFollowing_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AccumuloProxy_getFollowing_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t AccumuloProxy_getFollowing_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void AccumuloProxyClient::login(std::string& _return, const std::string& principal, const std::map<std::string, std::string> & loginProperties)
{
  send_login(principal, loginProperties);
  recv_login(_return);
}

void AccumuloProxyClient::send_login(const std::string& principal, const std::map<std::string, std::string> & loginProperties)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("login", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_login_pargs args;
  args.principal = &principal;
  args.loginProperties = &loginProperties;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_login(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("login") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_login_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "login failed: unknown result");
}

int32_t AccumuloProxyClient::addConstraint(const std::string& login, const std::string& tableName, const std::string& constraintClassName)
{
  send_addConstraint(login, tableName, constraintClassName);
  return recv_addConstraint();
}

void AccumuloProxyClient::send_addConstraint(const std::string& login, const std::string& tableName, const std::string& constraintClassName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("addConstraint", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_addConstraint_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.constraintClassName = &constraintClassName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t AccumuloProxyClient::recv_addConstraint()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("addConstraint") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  AccumuloProxy_addConstraint_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "addConstraint failed: unknown result");
}

void AccumuloProxyClient::addSplits(const std::string& login, const std::string& tableName, const std::set<std::string> & splits)
{
  send_addSplits(login, tableName, splits);
  recv_addSplits();
}

void AccumuloProxyClient::send_addSplits(const std::string& login, const std::string& tableName, const std::set<std::string> & splits)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("addSplits", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_addSplits_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.splits = &splits;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_addSplits()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("addSplits") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_addSplits_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::attachIterator(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes)
{
  send_attachIterator(login, tableName, setting, scopes);
  recv_attachIterator();
}

void AccumuloProxyClient::send_attachIterator(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("attachIterator", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_attachIterator_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.setting = &setting;
  args.scopes = &scopes;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_attachIterator()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("attachIterator") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_attachIterator_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::checkIteratorConflicts(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes)
{
  send_checkIteratorConflicts(login, tableName, setting, scopes);
  recv_checkIteratorConflicts();
}

void AccumuloProxyClient::send_checkIteratorConflicts(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("checkIteratorConflicts", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_checkIteratorConflicts_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.setting = &setting;
  args.scopes = &scopes;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_checkIteratorConflicts()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("checkIteratorConflicts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_checkIteratorConflicts_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::clearLocatorCache(const std::string& login, const std::string& tableName)
{
  send_clearLocatorCache(login, tableName);
  recv_clearLocatorCache();
}

void AccumuloProxyClient::send_clearLocatorCache(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("clearLocatorCache", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_clearLocatorCache_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_clearLocatorCache()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("clearLocatorCache") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_clearLocatorCache_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  return;
}

void AccumuloProxyClient::cloneTable(const std::string& login, const std::string& tableName, const std::string& newTableName, const bool flush, const std::map<std::string, std::string> & propertiesToSet, const std::set<std::string> & propertiesToExclude)
{
  send_cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude);
  recv_cloneTable();
}

void AccumuloProxyClient::send_cloneTable(const std::string& login, const std::string& tableName, const std::string& newTableName, const bool flush, const std::map<std::string, std::string> & propertiesToSet, const std::set<std::string> & propertiesToExclude)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("cloneTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_cloneTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.newTableName = &newTableName;
  args.flush = &flush;
  args.propertiesToSet = &propertiesToSet;
  args.propertiesToExclude = &propertiesToExclude;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_cloneTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("cloneTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_cloneTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  if (result.__isset.ouch4) {
    throw result.ouch4;
  }
  return;
}

void AccumuloProxyClient::compactTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const std::vector<IteratorSetting> & iterators, const bool flush, const bool wait)
{
  send_compactTable(login, tableName, startRow, endRow, iterators, flush, wait);
  recv_compactTable();
}

void AccumuloProxyClient::send_compactTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const std::vector<IteratorSetting> & iterators, const bool flush, const bool wait)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("compactTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_compactTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.iterators = &iterators;
  args.flush = &flush;
  args.wait = &wait;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_compactTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("compactTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_compactTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::cancelCompaction(const std::string& login, const std::string& tableName)
{
  send_cancelCompaction(login, tableName);
  recv_cancelCompaction();
}

void AccumuloProxyClient::send_cancelCompaction(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("cancelCompaction", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_cancelCompaction_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_cancelCompaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("cancelCompaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_cancelCompaction_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::createTable(const std::string& login, const std::string& tableName, const bool versioningIter, const TimeType::type type)
{
  send_createTable(login, tableName, versioningIter, type);
  recv_createTable();
}

void AccumuloProxyClient::send_createTable(const std::string& login, const std::string& tableName, const bool versioningIter, const TimeType::type type)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_createTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.versioningIter = &versioningIter;
  args.type = &type;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_createTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_createTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::deleteTable(const std::string& login, const std::string& tableName)
{
  send_deleteTable(login, tableName);
  recv_deleteTable();
}

void AccumuloProxyClient::send_deleteTable(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_deleteTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_deleteTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_deleteTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::deleteRows(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow)
{
  send_deleteRows(login, tableName, startRow, endRow);
  recv_deleteRows();
}

void AccumuloProxyClient::send_deleteRows(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteRows", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_deleteRows_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_deleteRows()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteRows") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_deleteRows_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::exportTable(const std::string& login, const std::string& tableName, const std::string& exportDir)
{
  send_exportTable(login, tableName, exportDir);
  recv_exportTable();
}

void AccumuloProxyClient::send_exportTable(const std::string& login, const std::string& tableName, const std::string& exportDir)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("exportTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_exportTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.exportDir = &exportDir;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_exportTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("exportTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_exportTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::flushTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const bool wait)
{
  send_flushTable(login, tableName, startRow, endRow, wait);
  recv_flushTable();
}

void AccumuloProxyClient::send_flushTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const bool wait)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("flushTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_flushTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.wait = &wait;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_flushTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("flushTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_flushTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::getDiskUsage(std::vector<DiskUsage> & _return, const std::string& login, const std::set<std::string> & tables)
{
  send_getDiskUsage(login, tables);
  recv_getDiskUsage(_return);
}

void AccumuloProxyClient::send_getDiskUsage(const std::string& login, const std::set<std::string> & tables)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getDiskUsage", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getDiskUsage_pargs args;
  args.login = &login;
  args.tables = &tables;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getDiskUsage(std::vector<DiskUsage> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getDiskUsage") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getDiskUsage_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDiskUsage failed: unknown result");
}

void AccumuloProxyClient::getLocalityGroups(std::map<std::string, std::set<std::string> > & _return, const std::string& login, const std::string& tableName)
{
  send_getLocalityGroups(login, tableName);
  recv_getLocalityGroups(_return);
}

void AccumuloProxyClient::send_getLocalityGroups(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getLocalityGroups", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getLocalityGroups_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getLocalityGroups(std::map<std::string, std::set<std::string> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getLocalityGroups") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getLocalityGroups_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getLocalityGroups failed: unknown result");
}

void AccumuloProxyClient::getIteratorSetting(IteratorSetting& _return, const std::string& login, const std::string& tableName, const std::string& iteratorName, const IteratorScope::type scope)
{
  send_getIteratorSetting(login, tableName, iteratorName, scope);
  recv_getIteratorSetting(_return);
}

void AccumuloProxyClient::send_getIteratorSetting(const std::string& login, const std::string& tableName, const std::string& iteratorName, const IteratorScope::type scope)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getIteratorSetting", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getIteratorSetting_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.iteratorName = &iteratorName;
  args.scope = &scope;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getIteratorSetting(IteratorSetting& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getIteratorSetting") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getIteratorSetting_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getIteratorSetting failed: unknown result");
}

void AccumuloProxyClient::getMaxRow(std::string& _return, const std::string& login, const std::string& tableName, const std::set<std::string> & auths, const std::string& startRow, const bool startInclusive, const std::string& endRow, const bool endInclusive)
{
  send_getMaxRow(login, tableName, auths, startRow, startInclusive, endRow, endInclusive);
  recv_getMaxRow(_return);
}

void AccumuloProxyClient::send_getMaxRow(const std::string& login, const std::string& tableName, const std::set<std::string> & auths, const std::string& startRow, const bool startInclusive, const std::string& endRow, const bool endInclusive)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getMaxRow", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getMaxRow_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.auths = &auths;
  args.startRow = &startRow;
  args.startInclusive = &startInclusive;
  args.endRow = &endRow;
  args.endInclusive = &endInclusive;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getMaxRow(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getMaxRow") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getMaxRow_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getMaxRow failed: unknown result");
}

void AccumuloProxyClient::getTableProperties(std::map<std::string, std::string> & _return, const std::string& login, const std::string& tableName)
{
  send_getTableProperties(login, tableName);
  recv_getTableProperties(_return);
}

void AccumuloProxyClient::send_getTableProperties(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTableProperties", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getTableProperties_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getTableProperties(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTableProperties") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getTableProperties_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTableProperties failed: unknown result");
}

void AccumuloProxyClient::importDirectory(const std::string& login, const std::string& tableName, const std::string& importDir, const std::string& failureDir, const bool setTime)
{
  send_importDirectory(login, tableName, importDir, failureDir, setTime);
  recv_importDirectory();
}

void AccumuloProxyClient::send_importDirectory(const std::string& login, const std::string& tableName, const std::string& importDir, const std::string& failureDir, const bool setTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("importDirectory", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_importDirectory_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.importDir = &importDir;
  args.failureDir = &failureDir;
  args.setTime = &setTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_importDirectory()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("importDirectory") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_importDirectory_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  if (result.__isset.ouch4) {
    throw result.ouch4;
  }
  return;
}

void AccumuloProxyClient::importTable(const std::string& login, const std::string& tableName, const std::string& importDir)
{
  send_importTable(login, tableName, importDir);
  recv_importTable();
}

void AccumuloProxyClient::send_importTable(const std::string& login, const std::string& tableName, const std::string& importDir)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("importTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_importTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.importDir = &importDir;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_importTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("importTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_importTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::listSplits(std::vector<std::string> & _return, const std::string& login, const std::string& tableName, const int32_t maxSplits)
{
  send_listSplits(login, tableName, maxSplits);
  recv_listSplits(_return);
}

void AccumuloProxyClient::send_listSplits(const std::string& login, const std::string& tableName, const int32_t maxSplits)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listSplits", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_listSplits_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.maxSplits = &maxSplits;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_listSplits(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listSplits") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_listSplits_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listSplits failed: unknown result");
}

void AccumuloProxyClient::listTables(std::set<std::string> & _return, const std::string& login)
{
  send_listTables(login);
  recv_listTables(_return);
}

void AccumuloProxyClient::send_listTables(const std::string& login)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listTables", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_listTables_pargs args;
  args.login = &login;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_listTables(std::set<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listTables") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_listTables_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listTables failed: unknown result");
}

void AccumuloProxyClient::listIterators(std::map<std::string, std::set<IteratorScope::type> > & _return, const std::string& login, const std::string& tableName)
{
  send_listIterators(login, tableName);
  recv_listIterators(_return);
}

void AccumuloProxyClient::send_listIterators(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listIterators", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_listIterators_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_listIterators(std::map<std::string, std::set<IteratorScope::type> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listIterators") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_listIterators_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listIterators failed: unknown result");
}

void AccumuloProxyClient::listConstraints(std::map<std::string, int32_t> & _return, const std::string& login, const std::string& tableName)
{
  send_listConstraints(login, tableName);
  recv_listConstraints(_return);
}

void AccumuloProxyClient::send_listConstraints(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listConstraints", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_listConstraints_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_listConstraints(std::map<std::string, int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listConstraints") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_listConstraints_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listConstraints failed: unknown result");
}

void AccumuloProxyClient::mergeTablets(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow)
{
  send_mergeTablets(login, tableName, startRow, endRow);
  recv_mergeTablets();
}

void AccumuloProxyClient::send_mergeTablets(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("mergeTablets", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_mergeTablets_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_mergeTablets()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("mergeTablets") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_mergeTablets_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::offlineTable(const std::string& login, const std::string& tableName, const bool wait)
{
  send_offlineTable(login, tableName, wait);
  recv_offlineTable();
}

void AccumuloProxyClient::send_offlineTable(const std::string& login, const std::string& tableName, const bool wait)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("offlineTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_offlineTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.wait = &wait;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_offlineTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("offlineTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_offlineTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::onlineTable(const std::string& login, const std::string& tableName, const bool wait)
{
  send_onlineTable(login, tableName, wait);
  recv_onlineTable();
}

void AccumuloProxyClient::send_onlineTable(const std::string& login, const std::string& tableName, const bool wait)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("onlineTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_onlineTable_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.wait = &wait;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_onlineTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("onlineTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_onlineTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::removeConstraint(const std::string& login, const std::string& tableName, const int32_t constraint)
{
  send_removeConstraint(login, tableName, constraint);
  recv_removeConstraint();
}

void AccumuloProxyClient::send_removeConstraint(const std::string& login, const std::string& tableName, const int32_t constraint)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeConstraint", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_removeConstraint_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.constraint = &constraint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_removeConstraint()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeConstraint") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_removeConstraint_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::removeIterator(const std::string& login, const std::string& tableName, const std::string& iterName, const std::set<IteratorScope::type> & scopes)
{
  send_removeIterator(login, tableName, iterName, scopes);
  recv_removeIterator();
}

void AccumuloProxyClient::send_removeIterator(const std::string& login, const std::string& tableName, const std::string& iterName, const std::set<IteratorScope::type> & scopes)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeIterator", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_removeIterator_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.iterName = &iterName;
  args.scopes = &scopes;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_removeIterator()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeIterator") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_removeIterator_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::removeTableProperty(const std::string& login, const std::string& tableName, const std::string& property)
{
  send_removeTableProperty(login, tableName, property);
  recv_removeTableProperty();
}

void AccumuloProxyClient::send_removeTableProperty(const std::string& login, const std::string& tableName, const std::string& property)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeTableProperty", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_removeTableProperty_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.property = &property;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_removeTableProperty()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeTableProperty") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_removeTableProperty_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::renameTable(const std::string& login, const std::string& oldTableName, const std::string& newTableName)
{
  send_renameTable(login, oldTableName, newTableName);
  recv_renameTable();
}

void AccumuloProxyClient::send_renameTable(const std::string& login, const std::string& oldTableName, const std::string& newTableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("renameTable", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_renameTable_pargs args;
  args.login = &login;
  args.oldTableName = &oldTableName;
  args.newTableName = &newTableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_renameTable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("renameTable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_renameTable_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  if (result.__isset.ouch4) {
    throw result.ouch4;
  }
  return;
}

void AccumuloProxyClient::setLocalityGroups(const std::string& login, const std::string& tableName, const std::map<std::string, std::set<std::string> > & groups)
{
  send_setLocalityGroups(login, tableName, groups);
  recv_setLocalityGroups();
}

void AccumuloProxyClient::send_setLocalityGroups(const std::string& login, const std::string& tableName, const std::map<std::string, std::set<std::string> > & groups)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setLocalityGroups", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_setLocalityGroups_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.groups = &groups;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_setLocalityGroups()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setLocalityGroups") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_setLocalityGroups_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::setTableProperty(const std::string& login, const std::string& tableName, const std::string& property, const std::string& value)
{
  send_setTableProperty(login, tableName, property, value);
  recv_setTableProperty();
}

void AccumuloProxyClient::send_setTableProperty(const std::string& login, const std::string& tableName, const std::string& property, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setTableProperty", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_setTableProperty_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.property = &property;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_setTableProperty()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setTableProperty") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_setTableProperty_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::splitRangeByTablets(std::set<Range> & _return, const std::string& login, const std::string& tableName, const Range& range, const int32_t maxSplits)
{
  send_splitRangeByTablets(login, tableName, range, maxSplits);
  recv_splitRangeByTablets(_return);
}

void AccumuloProxyClient::send_splitRangeByTablets(const std::string& login, const std::string& tableName, const Range& range, const int32_t maxSplits)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("splitRangeByTablets", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_splitRangeByTablets_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.range = &range;
  args.maxSplits = &maxSplits;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_splitRangeByTablets(std::set<Range> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("splitRangeByTablets") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_splitRangeByTablets_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "splitRangeByTablets failed: unknown result");
}

bool AccumuloProxyClient::tableExists(const std::string& login, const std::string& tableName)
{
  send_tableExists(login, tableName);
  return recv_tableExists();
}

void AccumuloProxyClient::send_tableExists(const std::string& login, const std::string& tableName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("tableExists", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_tableExists_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool AccumuloProxyClient::recv_tableExists()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("tableExists") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  AccumuloProxy_tableExists_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "tableExists failed: unknown result");
}

void AccumuloProxyClient::tableIdMap(std::map<std::string, std::string> & _return, const std::string& login)
{
  send_tableIdMap(login);
  recv_tableIdMap(_return);
}

void AccumuloProxyClient::send_tableIdMap(const std::string& login)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("tableIdMap", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_tableIdMap_pargs args;
  args.login = &login;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_tableIdMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("tableIdMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_tableIdMap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "tableIdMap failed: unknown result");
}

bool AccumuloProxyClient::testTableClassLoad(const std::string& login, const std::string& tableName, const std::string& className, const std::string& asTypeName)
{
  send_testTableClassLoad(login, tableName, className, asTypeName);
  return recv_testTableClassLoad();
}

void AccumuloProxyClient::send_testTableClassLoad(const std::string& login, const std::string& tableName, const std::string& className, const std::string& asTypeName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("testTableClassLoad", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_testTableClassLoad_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.className = &className;
  args.asTypeName = &asTypeName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool AccumuloProxyClient::recv_testTableClassLoad()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testTableClassLoad") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  AccumuloProxy_testTableClassLoad_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTableClassLoad failed: unknown result");
}

void AccumuloProxyClient::pingTabletServer(const std::string& login, const std::string& tserver)
{
  send_pingTabletServer(login, tserver);
  recv_pingTabletServer();
}

void AccumuloProxyClient::send_pingTabletServer(const std::string& login, const std::string& tserver)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("pingTabletServer", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_pingTabletServer_pargs args;
  args.login = &login;
  args.tserver = &tserver;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_pingTabletServer()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("pingTabletServer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_pingTabletServer_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::getActiveScans(std::vector<ActiveScan> & _return, const std::string& login, const std::string& tserver)
{
  send_getActiveScans(login, tserver);
  recv_getActiveScans(_return);
}

void AccumuloProxyClient::send_getActiveScans(const std::string& login, const std::string& tserver)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getActiveScans", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getActiveScans_pargs args;
  args.login = &login;
  args.tserver = &tserver;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getActiveScans(std::vector<ActiveScan> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getActiveScans") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getActiveScans_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveScans failed: unknown result");
}

void AccumuloProxyClient::getActiveCompactions(std::vector<ActiveCompaction> & _return, const std::string& login, const std::string& tserver)
{
  send_getActiveCompactions(login, tserver);
  recv_getActiveCompactions(_return);
}

void AccumuloProxyClient::send_getActiveCompactions(const std::string& login, const std::string& tserver)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getActiveCompactions", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getActiveCompactions_pargs args;
  args.login = &login;
  args.tserver = &tserver;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getActiveCompactions(std::vector<ActiveCompaction> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getActiveCompactions") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getActiveCompactions_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveCompactions failed: unknown result");
}

void AccumuloProxyClient::getSiteConfiguration(std::map<std::string, std::string> & _return, const std::string& login)
{
  send_getSiteConfiguration(login);
  recv_getSiteConfiguration(_return);
}

void AccumuloProxyClient::send_getSiteConfiguration(const std::string& login)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSiteConfiguration", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getSiteConfiguration_pargs args;
  args.login = &login;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getSiteConfiguration(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSiteConfiguration") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getSiteConfiguration_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSiteConfiguration failed: unknown result");
}

void AccumuloProxyClient::getSystemConfiguration(std::map<std::string, std::string> & _return, const std::string& login)
{
  send_getSystemConfiguration(login);
  recv_getSystemConfiguration(_return);
}

void AccumuloProxyClient::send_getSystemConfiguration(const std::string& login)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSystemConfiguration", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getSystemConfiguration_pargs args;
  args.login = &login;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getSystemConfiguration(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSystemConfiguration") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getSystemConfiguration_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSystemConfiguration failed: unknown result");
}

void AccumuloProxyClient::getTabletServers(std::vector<std::string> & _return, const std::string& login)
{
  send_getTabletServers(login);
  recv_getTabletServers(_return);
}

void AccumuloProxyClient::send_getTabletServers(const std::string& login)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTabletServers", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getTabletServers_pargs args;
  args.login = &login;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getTabletServers(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTabletServers") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getTabletServers_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTabletServers failed: unknown result");
}

void AccumuloProxyClient::removeProperty(const std::string& login, const std::string& property)
{
  send_removeProperty(login, property);
  recv_removeProperty();
}

void AccumuloProxyClient::send_removeProperty(const std::string& login, const std::string& property)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeProperty", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_removeProperty_pargs args;
  args.login = &login;
  args.property = &property;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_removeProperty()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeProperty") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_removeProperty_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::setProperty(const std::string& login, const std::string& property, const std::string& value)
{
  send_setProperty(login, property, value);
  recv_setProperty();
}

void AccumuloProxyClient::send_setProperty(const std::string& login, const std::string& property, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setProperty", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_setProperty_pargs args;
  args.login = &login;
  args.property = &property;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_setProperty()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setProperty") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_setProperty_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

bool AccumuloProxyClient::testClassLoad(const std::string& login, const std::string& className, const std::string& asTypeName)
{
  send_testClassLoad(login, className, asTypeName);
  return recv_testClassLoad();
}

void AccumuloProxyClient::send_testClassLoad(const std::string& login, const std::string& className, const std::string& asTypeName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("testClassLoad", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_testClassLoad_pargs args;
  args.login = &login;
  args.className = &className;
  args.asTypeName = &asTypeName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool AccumuloProxyClient::recv_testClassLoad()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testClassLoad") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  AccumuloProxy_testClassLoad_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testClassLoad failed: unknown result");
}

bool AccumuloProxyClient::authenticateUser(const std::string& login, const std::string& user, const std::map<std::string, std::string> & properties)
{
  send_authenticateUser(login, user, properties);
  return recv_authenticateUser();
}

void AccumuloProxyClient::send_authenticateUser(const std::string& login, const std::string& user, const std::map<std::string, std::string> & properties)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("authenticateUser", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_authenticateUser_pargs args;
  args.login = &login;
  args.user = &user;
  args.properties = &properties;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool AccumuloProxyClient::recv_authenticateUser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("authenticateUser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  AccumuloProxy_authenticateUser_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "authenticateUser failed: unknown result");
}

void AccumuloProxyClient::changeUserAuthorizations(const std::string& login, const std::string& user, const std::set<std::string> & authorizations)
{
  send_changeUserAuthorizations(login, user, authorizations);
  recv_changeUserAuthorizations();
}

void AccumuloProxyClient::send_changeUserAuthorizations(const std::string& login, const std::string& user, const std::set<std::string> & authorizations)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("changeUserAuthorizations", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_changeUserAuthorizations_pargs args;
  args.login = &login;
  args.user = &user;
  args.authorizations = &authorizations;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_changeUserAuthorizations()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("changeUserAuthorizations") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_changeUserAuthorizations_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::changeLocalUserPassword(const std::string& login, const std::string& user, const std::string& password)
{
  send_changeLocalUserPassword(login, user, password);
  recv_changeLocalUserPassword();
}

void AccumuloProxyClient::send_changeLocalUserPassword(const std::string& login, const std::string& user, const std::string& password)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("changeLocalUserPassword", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_changeLocalUserPassword_pargs args;
  args.login = &login;
  args.user = &user;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_changeLocalUserPassword()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("changeLocalUserPassword") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_changeLocalUserPassword_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::createLocalUser(const std::string& login, const std::string& user, const std::string& password)
{
  send_createLocalUser(login, user, password);
  recv_createLocalUser();
}

void AccumuloProxyClient::send_createLocalUser(const std::string& login, const std::string& user, const std::string& password)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createLocalUser", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_createLocalUser_pargs args;
  args.login = &login;
  args.user = &user;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_createLocalUser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createLocalUser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_createLocalUser_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::dropLocalUser(const std::string& login, const std::string& user)
{
  send_dropLocalUser(login, user);
  recv_dropLocalUser();
}

void AccumuloProxyClient::send_dropLocalUser(const std::string& login, const std::string& user)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("dropLocalUser", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_dropLocalUser_pargs args;
  args.login = &login;
  args.user = &user;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_dropLocalUser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("dropLocalUser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_dropLocalUser_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::getUserAuthorizations(std::vector<std::string> & _return, const std::string& login, const std::string& user)
{
  send_getUserAuthorizations(login, user);
  recv_getUserAuthorizations(_return);
}

void AccumuloProxyClient::send_getUserAuthorizations(const std::string& login, const std::string& user)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getUserAuthorizations", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getUserAuthorizations_pargs args;
  args.login = &login;
  args.user = &user;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getUserAuthorizations(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getUserAuthorizations") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getUserAuthorizations_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getUserAuthorizations failed: unknown result");
}

void AccumuloProxyClient::grantSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm)
{
  send_grantSystemPermission(login, user, perm);
  recv_grantSystemPermission();
}

void AccumuloProxyClient::send_grantSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("grantSystemPermission", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_grantSystemPermission_pargs args;
  args.login = &login;
  args.user = &user;
  args.perm = &perm;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_grantSystemPermission()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("grantSystemPermission") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_grantSystemPermission_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::grantTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm)
{
  send_grantTablePermission(login, user, table, perm);
  recv_grantTablePermission();
}

void AccumuloProxyClient::send_grantTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("grantTablePermission", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_grantTablePermission_pargs args;
  args.login = &login;
  args.user = &user;
  args.table = &table;
  args.perm = &perm;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_grantTablePermission()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("grantTablePermission") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_grantTablePermission_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

bool AccumuloProxyClient::hasSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm)
{
  send_hasSystemPermission(login, user, perm);
  return recv_hasSystemPermission();
}

void AccumuloProxyClient::send_hasSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("hasSystemPermission", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_hasSystemPermission_pargs args;
  args.login = &login;
  args.user = &user;
  args.perm = &perm;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool AccumuloProxyClient::recv_hasSystemPermission()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("hasSystemPermission") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  AccumuloProxy_hasSystemPermission_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "hasSystemPermission failed: unknown result");
}

bool AccumuloProxyClient::hasTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm)
{
  send_hasTablePermission(login, user, table, perm);
  return recv_hasTablePermission();
}

void AccumuloProxyClient::send_hasTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("hasTablePermission", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_hasTablePermission_pargs args;
  args.login = &login;
  args.user = &user;
  args.table = &table;
  args.perm = &perm;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool AccumuloProxyClient::recv_hasTablePermission()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("hasTablePermission") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  AccumuloProxy_hasTablePermission_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "hasTablePermission failed: unknown result");
}

void AccumuloProxyClient::listLocalUsers(std::set<std::string> & _return, const std::string& login)
{
  send_listLocalUsers(login);
  recv_listLocalUsers(_return);
}

void AccumuloProxyClient::send_listLocalUsers(const std::string& login)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("listLocalUsers", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_listLocalUsers_pargs args;
  args.login = &login;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_listLocalUsers(std::set<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("listLocalUsers") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_listLocalUsers_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "listLocalUsers failed: unknown result");
}

void AccumuloProxyClient::revokeSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm)
{
  send_revokeSystemPermission(login, user, perm);
  recv_revokeSystemPermission();
}

void AccumuloProxyClient::send_revokeSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("revokeSystemPermission", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_revokeSystemPermission_pargs args;
  args.login = &login;
  args.user = &user;
  args.perm = &perm;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_revokeSystemPermission()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("revokeSystemPermission") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_revokeSystemPermission_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::revokeTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm)
{
  send_revokeTablePermission(login, user, table, perm);
  recv_revokeTablePermission();
}

void AccumuloProxyClient::send_revokeTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("revokeTablePermission", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_revokeTablePermission_pargs args;
  args.login = &login;
  args.user = &user;
  args.table = &table;
  args.perm = &perm;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_revokeTablePermission()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("revokeTablePermission") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_revokeTablePermission_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  return;
}

void AccumuloProxyClient::createBatchScanner(std::string& _return, const std::string& login, const std::string& tableName, const BatchScanOptions& options)
{
  send_createBatchScanner(login, tableName, options);
  recv_createBatchScanner(_return);
}

void AccumuloProxyClient::send_createBatchScanner(const std::string& login, const std::string& tableName, const BatchScanOptions& options)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createBatchScanner", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_createBatchScanner_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_createBatchScanner(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createBatchScanner") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_createBatchScanner_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createBatchScanner failed: unknown result");
}

void AccumuloProxyClient::createScanner(std::string& _return, const std::string& login, const std::string& tableName, const ScanOptions& options)
{
  send_createScanner(login, tableName, options);
  recv_createScanner(_return);
}

void AccumuloProxyClient::send_createScanner(const std::string& login, const std::string& tableName, const ScanOptions& options)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createScanner", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_createScanner_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_createScanner(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createScanner") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_createScanner_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createScanner failed: unknown result");
}

bool AccumuloProxyClient::hasNext(const std::string& scanner)
{
  send_hasNext(scanner);
  return recv_hasNext();
}

void AccumuloProxyClient::send_hasNext(const std::string& scanner)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("hasNext", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_hasNext_pargs args;
  args.scanner = &scanner;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool AccumuloProxyClient::recv_hasNext()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("hasNext") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  AccumuloProxy_hasNext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "hasNext failed: unknown result");
}

void AccumuloProxyClient::nextEntry(KeyValueAndPeek& _return, const std::string& scanner)
{
  send_nextEntry(scanner);
  recv_nextEntry(_return);
}

void AccumuloProxyClient::send_nextEntry(const std::string& scanner)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("nextEntry", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_nextEntry_pargs args;
  args.scanner = &scanner;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_nextEntry(KeyValueAndPeek& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("nextEntry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_nextEntry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "nextEntry failed: unknown result");
}

void AccumuloProxyClient::nextK(ScanResult& _return, const std::string& scanner, const int32_t k)
{
  send_nextK(scanner, k);
  recv_nextK(_return);
}

void AccumuloProxyClient::send_nextK(const std::string& scanner, const int32_t k)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("nextK", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_nextK_pargs args;
  args.scanner = &scanner;
  args.k = &k;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_nextK(ScanResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("nextK") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_nextK_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "nextK failed: unknown result");
}

void AccumuloProxyClient::closeScanner(const std::string& scanner)
{
  send_closeScanner(scanner);
  recv_closeScanner();
}

void AccumuloProxyClient::send_closeScanner(const std::string& scanner)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeScanner", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_closeScanner_pargs args;
  args.scanner = &scanner;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_closeScanner()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeScanner") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_closeScanner_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  return;
}

void AccumuloProxyClient::updateAndFlush(const std::string& login, const std::string& tableName, const std::map<std::string, std::vector<ColumnUpdate> > & cells)
{
  send_updateAndFlush(login, tableName, cells);
  recv_updateAndFlush();
}

void AccumuloProxyClient::send_updateAndFlush(const std::string& login, const std::string& tableName, const std::map<std::string, std::vector<ColumnUpdate> > & cells)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateAndFlush", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_updateAndFlush_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.cells = &cells;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_updateAndFlush()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateAndFlush") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_updateAndFlush_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.outch1) {
    throw result.outch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  if (result.__isset.ouch4) {
    throw result.ouch4;
  }
  return;
}

void AccumuloProxyClient::createWriter(std::string& _return, const std::string& login, const std::string& tableName, const WriterOptions& opts)
{
  send_createWriter(login, tableName, opts);
  recv_createWriter(_return);
}

void AccumuloProxyClient::send_createWriter(const std::string& login, const std::string& tableName, const WriterOptions& opts)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createWriter", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_createWriter_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.opts = &opts;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_createWriter(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createWriter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_createWriter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.outch1) {
    throw result.outch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createWriter failed: unknown result");
}

void AccumuloProxyClient::update(const std::string& writer, const std::map<std::string, std::vector<ColumnUpdate> > & cells)
{
  send_update(writer, cells);
}

void AccumuloProxyClient::send_update(const std::string& writer, const std::map<std::string, std::vector<ColumnUpdate> > & cells)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("update", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_update_pargs args;
  args.writer = &writer;
  args.cells = &cells;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::flush(const std::string& writer)
{
  send_flush(writer);
  recv_flush();
}

void AccumuloProxyClient::send_flush(const std::string& writer)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("flush", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_flush_pargs args;
  args.writer = &writer;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_flush()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("flush") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_flush_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

void AccumuloProxyClient::closeWriter(const std::string& writer)
{
  send_closeWriter(writer);
  recv_closeWriter();
}

void AccumuloProxyClient::send_closeWriter(const std::string& writer)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeWriter", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_closeWriter_pargs args;
  args.writer = &writer;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_closeWriter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeWriter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_closeWriter_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  return;
}

ConditionalStatus::type AccumuloProxyClient::updateRowConditionally(const std::string& login, const std::string& tableName, const std::string& row, const ConditionalUpdates& updates)
{
  send_updateRowConditionally(login, tableName, row, updates);
  return recv_updateRowConditionally();
}

void AccumuloProxyClient::send_updateRowConditionally(const std::string& login, const std::string& tableName, const std::string& row, const ConditionalUpdates& updates)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateRowConditionally", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_updateRowConditionally_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.row = &row;
  args.updates = &updates;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

ConditionalStatus::type AccumuloProxyClient::recv_updateRowConditionally()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateRowConditionally") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ConditionalStatus::type _return;
  AccumuloProxy_updateRowConditionally_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateRowConditionally failed: unknown result");
}

void AccumuloProxyClient::createConditionalWriter(std::string& _return, const std::string& login, const std::string& tableName, const ConditionalWriterOptions& options)
{
  send_createConditionalWriter(login, tableName, options);
  recv_createConditionalWriter(_return);
}

void AccumuloProxyClient::send_createConditionalWriter(const std::string& login, const std::string& tableName, const ConditionalWriterOptions& options)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createConditionalWriter", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_createConditionalWriter_pargs args;
  args.login = &login;
  args.tableName = &tableName;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_createConditionalWriter(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createConditionalWriter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_createConditionalWriter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createConditionalWriter failed: unknown result");
}

void AccumuloProxyClient::updateRowsConditionally(std::map<std::string, ConditionalStatus::type> & _return, const std::string& conditionalWriter, const std::map<std::string, ConditionalUpdates> & updates)
{
  send_updateRowsConditionally(conditionalWriter, updates);
  recv_updateRowsConditionally(_return);
}

void AccumuloProxyClient::send_updateRowsConditionally(const std::string& conditionalWriter, const std::map<std::string, ConditionalUpdates> & updates)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateRowsConditionally", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_updateRowsConditionally_pargs args;
  args.conditionalWriter = &conditionalWriter;
  args.updates = &updates;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_updateRowsConditionally(std::map<std::string, ConditionalStatus::type> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateRowsConditionally") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_updateRowsConditionally_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch1) {
    throw result.ouch1;
  }
  if (result.__isset.ouch2) {
    throw result.ouch2;
  }
  if (result.__isset.ouch3) {
    throw result.ouch3;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateRowsConditionally failed: unknown result");
}

void AccumuloProxyClient::closeConditionalWriter(const std::string& conditionalWriter)
{
  send_closeConditionalWriter(conditionalWriter);
  recv_closeConditionalWriter();
}

void AccumuloProxyClient::send_closeConditionalWriter(const std::string& conditionalWriter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeConditionalWriter", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_closeConditionalWriter_pargs args;
  args.conditionalWriter = &conditionalWriter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_closeConditionalWriter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeConditionalWriter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_closeConditionalWriter_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void AccumuloProxyClient::getRowRange(Range& _return, const std::string& row)
{
  send_getRowRange(row);
  recv_getRowRange(_return);
}

void AccumuloProxyClient::send_getRowRange(const std::string& row)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRowRange", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getRowRange_pargs args;
  args.row = &row;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getRowRange(Range& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRowRange") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getRowRange_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRowRange failed: unknown result");
}

void AccumuloProxyClient::getFollowing(Key& _return, const Key& key, const PartialKey::type part)
{
  send_getFollowing(key, part);
  recv_getFollowing(_return);
}

void AccumuloProxyClient::send_getFollowing(const Key& key, const PartialKey::type part)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getFollowing", ::apache::thrift::protocol::T_CALL, cseqid);

  AccumuloProxy_getFollowing_pargs args;
  args.key = &key;
  args.part = &part;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AccumuloProxyClient::recv_getFollowing(Key& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getFollowing") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AccumuloProxy_getFollowing_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getFollowing failed: unknown result");
}

bool AccumuloProxyProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void AccumuloProxyProcessor::process_login(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.login", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.login");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.login");
  }

  AccumuloProxy_login_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.login", bytes);
  }

  AccumuloProxy_login_result result;
  try {
    iface_->login(result.success, args.principal, args.loginProperties);
    result.__isset.success = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.login");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("login", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.login");
  }

  oprot->writeMessageBegin("login", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.login", bytes);
  }
}

void AccumuloProxyProcessor::process_addConstraint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.addConstraint", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.addConstraint");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.addConstraint");
  }

  AccumuloProxy_addConstraint_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.addConstraint", bytes);
  }

  AccumuloProxy_addConstraint_result result;
  try {
    result.success = iface_->addConstraint(args.login, args.tableName, args.constraintClassName);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.addConstraint");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("addConstraint", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.addConstraint");
  }

  oprot->writeMessageBegin("addConstraint", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.addConstraint", bytes);
  }
}

void AccumuloProxyProcessor::process_addSplits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.addSplits", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.addSplits");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.addSplits");
  }

  AccumuloProxy_addSplits_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.addSplits", bytes);
  }

  AccumuloProxy_addSplits_result result;
  try {
    iface_->addSplits(args.login, args.tableName, args.splits);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.addSplits");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("addSplits", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.addSplits");
  }

  oprot->writeMessageBegin("addSplits", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.addSplits", bytes);
  }
}

void AccumuloProxyProcessor::process_attachIterator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.attachIterator", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.attachIterator");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.attachIterator");
  }

  AccumuloProxy_attachIterator_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.attachIterator", bytes);
  }

  AccumuloProxy_attachIterator_result result;
  try {
    iface_->attachIterator(args.login, args.tableName, args.setting, args.scopes);
  } catch (AccumuloSecurityException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.attachIterator");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("attachIterator", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.attachIterator");
  }

  oprot->writeMessageBegin("attachIterator", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.attachIterator", bytes);
  }
}

void AccumuloProxyProcessor::process_checkIteratorConflicts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.checkIteratorConflicts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.checkIteratorConflicts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.checkIteratorConflicts");
  }

  AccumuloProxy_checkIteratorConflicts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.checkIteratorConflicts", bytes);
  }

  AccumuloProxy_checkIteratorConflicts_result result;
  try {
    iface_->checkIteratorConflicts(args.login, args.tableName, args.setting, args.scopes);
  } catch (AccumuloSecurityException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.checkIteratorConflicts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("checkIteratorConflicts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.checkIteratorConflicts");
  }

  oprot->writeMessageBegin("checkIteratorConflicts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.checkIteratorConflicts", bytes);
  }
}

void AccumuloProxyProcessor::process_clearLocatorCache(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.clearLocatorCache", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.clearLocatorCache");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.clearLocatorCache");
  }

  AccumuloProxy_clearLocatorCache_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.clearLocatorCache", bytes);
  }

  AccumuloProxy_clearLocatorCache_result result;
  try {
    iface_->clearLocatorCache(args.login, args.tableName);
  } catch (TableNotFoundException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.clearLocatorCache");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("clearLocatorCache", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.clearLocatorCache");
  }

  oprot->writeMessageBegin("clearLocatorCache", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.clearLocatorCache", bytes);
  }
}

void AccumuloProxyProcessor::process_cloneTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.cloneTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.cloneTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.cloneTable");
  }

  AccumuloProxy_cloneTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.cloneTable", bytes);
  }

  AccumuloProxy_cloneTable_result result;
  try {
    iface_->cloneTable(args.login, args.tableName, args.newTableName, args.flush, args.propertiesToSet, args.propertiesToExclude);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (TableExistsException &ouch4) {
    result.ouch4 = ouch4;
    result.__isset.ouch4 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.cloneTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("cloneTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.cloneTable");
  }

  oprot->writeMessageBegin("cloneTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.cloneTable", bytes);
  }
}

void AccumuloProxyProcessor::process_compactTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.compactTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.compactTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.compactTable");
  }

  AccumuloProxy_compactTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.compactTable", bytes);
  }

  AccumuloProxy_compactTable_result result;
  try {
    iface_->compactTable(args.login, args.tableName, args.startRow, args.endRow, args.iterators, args.flush, args.wait);
  } catch (AccumuloSecurityException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (TableNotFoundException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (AccumuloException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.compactTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("compactTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.compactTable");
  }

  oprot->writeMessageBegin("compactTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.compactTable", bytes);
  }
}

void AccumuloProxyProcessor::process_cancelCompaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.cancelCompaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.cancelCompaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.cancelCompaction");
  }

  AccumuloProxy_cancelCompaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.cancelCompaction", bytes);
  }

  AccumuloProxy_cancelCompaction_result result;
  try {
    iface_->cancelCompaction(args.login, args.tableName);
  } catch (AccumuloSecurityException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (TableNotFoundException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (AccumuloException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.cancelCompaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("cancelCompaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.cancelCompaction");
  }

  oprot->writeMessageBegin("cancelCompaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.cancelCompaction", bytes);
  }
}

void AccumuloProxyProcessor::process_createTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.createTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.createTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.createTable");
  }

  AccumuloProxy_createTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.createTable", bytes);
  }

  AccumuloProxy_createTable_result result;
  try {
    iface_->createTable(args.login, args.tableName, args.versioningIter, args.type);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableExistsException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.createTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.createTable");
  }

  oprot->writeMessageBegin("createTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.createTable", bytes);
  }
}

void AccumuloProxyProcessor::process_deleteTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.deleteTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.deleteTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.deleteTable");
  }

  AccumuloProxy_deleteTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.deleteTable", bytes);
  }

  AccumuloProxy_deleteTable_result result;
  try {
    iface_->deleteTable(args.login, args.tableName);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.deleteTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.deleteTable");
  }

  oprot->writeMessageBegin("deleteTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.deleteTable", bytes);
  }
}

void AccumuloProxyProcessor::process_deleteRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.deleteRows", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.deleteRows");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.deleteRows");
  }

  AccumuloProxy_deleteRows_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.deleteRows", bytes);
  }

  AccumuloProxy_deleteRows_result result;
  try {
    iface_->deleteRows(args.login, args.tableName, args.startRow, args.endRow);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.deleteRows");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteRows", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.deleteRows");
  }

  oprot->writeMessageBegin("deleteRows", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.deleteRows", bytes);
  }
}

void AccumuloProxyProcessor::process_exportTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.exportTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.exportTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.exportTable");
  }

  AccumuloProxy_exportTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.exportTable", bytes);
  }

  AccumuloProxy_exportTable_result result;
  try {
    iface_->exportTable(args.login, args.tableName, args.exportDir);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.exportTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("exportTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.exportTable");
  }

  oprot->writeMessageBegin("exportTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.exportTable", bytes);
  }
}

void AccumuloProxyProcessor::process_flushTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.flushTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.flushTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.flushTable");
  }

  AccumuloProxy_flushTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.flushTable", bytes);
  }

  AccumuloProxy_flushTable_result result;
  try {
    iface_->flushTable(args.login, args.tableName, args.startRow, args.endRow, args.wait);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.flushTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("flushTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.flushTable");
  }

  oprot->writeMessageBegin("flushTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.flushTable", bytes);
  }
}

void AccumuloProxyProcessor::process_getDiskUsage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getDiskUsage", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getDiskUsage");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getDiskUsage");
  }

  AccumuloProxy_getDiskUsage_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getDiskUsage", bytes);
  }

  AccumuloProxy_getDiskUsage_result result;
  try {
    iface_->getDiskUsage(result.success, args.login, args.tables);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getDiskUsage");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getDiskUsage", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getDiskUsage");
  }

  oprot->writeMessageBegin("getDiskUsage", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getDiskUsage", bytes);
  }
}

void AccumuloProxyProcessor::process_getLocalityGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getLocalityGroups", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getLocalityGroups");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getLocalityGroups");
  }

  AccumuloProxy_getLocalityGroups_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getLocalityGroups", bytes);
  }

  AccumuloProxy_getLocalityGroups_result result;
  try {
    iface_->getLocalityGroups(result.success, args.login, args.tableName);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getLocalityGroups");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getLocalityGroups", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getLocalityGroups");
  }

  oprot->writeMessageBegin("getLocalityGroups", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getLocalityGroups", bytes);
  }
}

void AccumuloProxyProcessor::process_getIteratorSetting(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getIteratorSetting", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getIteratorSetting");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getIteratorSetting");
  }

  AccumuloProxy_getIteratorSetting_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getIteratorSetting", bytes);
  }

  AccumuloProxy_getIteratorSetting_result result;
  try {
    iface_->getIteratorSetting(result.success, args.login, args.tableName, args.iteratorName, args.scope);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getIteratorSetting");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getIteratorSetting", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getIteratorSetting");
  }

  oprot->writeMessageBegin("getIteratorSetting", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getIteratorSetting", bytes);
  }
}

void AccumuloProxyProcessor::process_getMaxRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getMaxRow", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getMaxRow");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getMaxRow");
  }

  AccumuloProxy_getMaxRow_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getMaxRow", bytes);
  }

  AccumuloProxy_getMaxRow_result result;
  try {
    iface_->getMaxRow(result.success, args.login, args.tableName, args.auths, args.startRow, args.startInclusive, args.endRow, args.endInclusive);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getMaxRow");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getMaxRow", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getMaxRow");
  }

  oprot->writeMessageBegin("getMaxRow", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getMaxRow", bytes);
  }
}

void AccumuloProxyProcessor::process_getTableProperties(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getTableProperties", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getTableProperties");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getTableProperties");
  }

  AccumuloProxy_getTableProperties_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getTableProperties", bytes);
  }

  AccumuloProxy_getTableProperties_result result;
  try {
    iface_->getTableProperties(result.success, args.login, args.tableName);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getTableProperties");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTableProperties", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getTableProperties");
  }

  oprot->writeMessageBegin("getTableProperties", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getTableProperties", bytes);
  }
}

void AccumuloProxyProcessor::process_importDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.importDirectory", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.importDirectory");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.importDirectory");
  }

  AccumuloProxy_importDirectory_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.importDirectory", bytes);
  }

  AccumuloProxy_importDirectory_result result;
  try {
    iface_->importDirectory(args.login, args.tableName, args.importDir, args.failureDir, args.setTime);
  } catch (TableNotFoundException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (AccumuloSecurityException &ouch4) {
    result.ouch4 = ouch4;
    result.__isset.ouch4 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.importDirectory");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("importDirectory", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.importDirectory");
  }

  oprot->writeMessageBegin("importDirectory", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.importDirectory", bytes);
  }
}

void AccumuloProxyProcessor::process_importTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.importTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.importTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.importTable");
  }

  AccumuloProxy_importTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.importTable", bytes);
  }

  AccumuloProxy_importTable_result result;
  try {
    iface_->importTable(args.login, args.tableName, args.importDir);
  } catch (TableExistsException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (AccumuloSecurityException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.importTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("importTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.importTable");
  }

  oprot->writeMessageBegin("importTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.importTable", bytes);
  }
}

void AccumuloProxyProcessor::process_listSplits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.listSplits", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.listSplits");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.listSplits");
  }

  AccumuloProxy_listSplits_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.listSplits", bytes);
  }

  AccumuloProxy_listSplits_result result;
  try {
    iface_->listSplits(result.success, args.login, args.tableName, args.maxSplits);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.listSplits");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listSplits", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.listSplits");
  }

  oprot->writeMessageBegin("listSplits", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.listSplits", bytes);
  }
}

void AccumuloProxyProcessor::process_listTables(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.listTables", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.listTables");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.listTables");
  }

  AccumuloProxy_listTables_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.listTables", bytes);
  }

  AccumuloProxy_listTables_result result;
  try {
    iface_->listTables(result.success, args.login);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.listTables");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listTables", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.listTables");
  }

  oprot->writeMessageBegin("listTables", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.listTables", bytes);
  }
}

void AccumuloProxyProcessor::process_listIterators(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.listIterators", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.listIterators");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.listIterators");
  }

  AccumuloProxy_listIterators_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.listIterators", bytes);
  }

  AccumuloProxy_listIterators_result result;
  try {
    iface_->listIterators(result.success, args.login, args.tableName);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.listIterators");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listIterators", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.listIterators");
  }

  oprot->writeMessageBegin("listIterators", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.listIterators", bytes);
  }
}

void AccumuloProxyProcessor::process_listConstraints(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.listConstraints", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.listConstraints");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.listConstraints");
  }

  AccumuloProxy_listConstraints_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.listConstraints", bytes);
  }

  AccumuloProxy_listConstraints_result result;
  try {
    iface_->listConstraints(result.success, args.login, args.tableName);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.listConstraints");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listConstraints", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.listConstraints");
  }

  oprot->writeMessageBegin("listConstraints", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.listConstraints", bytes);
  }
}

void AccumuloProxyProcessor::process_mergeTablets(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.mergeTablets", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.mergeTablets");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.mergeTablets");
  }

  AccumuloProxy_mergeTablets_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.mergeTablets", bytes);
  }

  AccumuloProxy_mergeTablets_result result;
  try {
    iface_->mergeTablets(args.login, args.tableName, args.startRow, args.endRow);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.mergeTablets");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("mergeTablets", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.mergeTablets");
  }

  oprot->writeMessageBegin("mergeTablets", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.mergeTablets", bytes);
  }
}

void AccumuloProxyProcessor::process_offlineTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.offlineTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.offlineTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.offlineTable");
  }

  AccumuloProxy_offlineTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.offlineTable", bytes);
  }

  AccumuloProxy_offlineTable_result result;
  try {
    iface_->offlineTable(args.login, args.tableName, args.wait);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.offlineTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("offlineTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.offlineTable");
  }

  oprot->writeMessageBegin("offlineTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.offlineTable", bytes);
  }
}

void AccumuloProxyProcessor::process_onlineTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.onlineTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.onlineTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.onlineTable");
  }

  AccumuloProxy_onlineTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.onlineTable", bytes);
  }

  AccumuloProxy_onlineTable_result result;
  try {
    iface_->onlineTable(args.login, args.tableName, args.wait);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.onlineTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("onlineTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.onlineTable");
  }

  oprot->writeMessageBegin("onlineTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.onlineTable", bytes);
  }
}

void AccumuloProxyProcessor::process_removeConstraint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.removeConstraint", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.removeConstraint");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.removeConstraint");
  }

  AccumuloProxy_removeConstraint_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.removeConstraint", bytes);
  }

  AccumuloProxy_removeConstraint_result result;
  try {
    iface_->removeConstraint(args.login, args.tableName, args.constraint);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.removeConstraint");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeConstraint", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.removeConstraint");
  }

  oprot->writeMessageBegin("removeConstraint", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.removeConstraint", bytes);
  }
}

void AccumuloProxyProcessor::process_removeIterator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.removeIterator", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.removeIterator");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.removeIterator");
  }

  AccumuloProxy_removeIterator_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.removeIterator", bytes);
  }

  AccumuloProxy_removeIterator_result result;
  try {
    iface_->removeIterator(args.login, args.tableName, args.iterName, args.scopes);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.removeIterator");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeIterator", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.removeIterator");
  }

  oprot->writeMessageBegin("removeIterator", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.removeIterator", bytes);
  }
}

void AccumuloProxyProcessor::process_removeTableProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.removeTableProperty", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.removeTableProperty");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.removeTableProperty");
  }

  AccumuloProxy_removeTableProperty_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.removeTableProperty", bytes);
  }

  AccumuloProxy_removeTableProperty_result result;
  try {
    iface_->removeTableProperty(args.login, args.tableName, args.property);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.removeTableProperty");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeTableProperty", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.removeTableProperty");
  }

  oprot->writeMessageBegin("removeTableProperty", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.removeTableProperty", bytes);
  }
}

void AccumuloProxyProcessor::process_renameTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.renameTable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.renameTable");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.renameTable");
  }

  AccumuloProxy_renameTable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.renameTable", bytes);
  }

  AccumuloProxy_renameTable_result result;
  try {
    iface_->renameTable(args.login, args.oldTableName, args.newTableName);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (TableExistsException &ouch4) {
    result.ouch4 = ouch4;
    result.__isset.ouch4 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.renameTable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("renameTable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.renameTable");
  }

  oprot->writeMessageBegin("renameTable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.renameTable", bytes);
  }
}

void AccumuloProxyProcessor::process_setLocalityGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.setLocalityGroups", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.setLocalityGroups");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.setLocalityGroups");
  }

  AccumuloProxy_setLocalityGroups_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.setLocalityGroups", bytes);
  }

  AccumuloProxy_setLocalityGroups_result result;
  try {
    iface_->setLocalityGroups(args.login, args.tableName, args.groups);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.setLocalityGroups");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setLocalityGroups", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.setLocalityGroups");
  }

  oprot->writeMessageBegin("setLocalityGroups", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.setLocalityGroups", bytes);
  }
}

void AccumuloProxyProcessor::process_setTableProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.setTableProperty", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.setTableProperty");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.setTableProperty");
  }

  AccumuloProxy_setTableProperty_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.setTableProperty", bytes);
  }

  AccumuloProxy_setTableProperty_result result;
  try {
    iface_->setTableProperty(args.login, args.tableName, args.property, args.value);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.setTableProperty");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setTableProperty", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.setTableProperty");
  }

  oprot->writeMessageBegin("setTableProperty", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.setTableProperty", bytes);
  }
}

void AccumuloProxyProcessor::process_splitRangeByTablets(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.splitRangeByTablets", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.splitRangeByTablets");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.splitRangeByTablets");
  }

  AccumuloProxy_splitRangeByTablets_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.splitRangeByTablets", bytes);
  }

  AccumuloProxy_splitRangeByTablets_result result;
  try {
    iface_->splitRangeByTablets(result.success, args.login, args.tableName, args.range, args.maxSplits);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.splitRangeByTablets");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("splitRangeByTablets", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.splitRangeByTablets");
  }

  oprot->writeMessageBegin("splitRangeByTablets", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.splitRangeByTablets", bytes);
  }
}

void AccumuloProxyProcessor::process_tableExists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.tableExists", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.tableExists");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.tableExists");
  }

  AccumuloProxy_tableExists_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.tableExists", bytes);
  }

  AccumuloProxy_tableExists_result result;
  try {
    result.success = iface_->tableExists(args.login, args.tableName);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.tableExists");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("tableExists", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.tableExists");
  }

  oprot->writeMessageBegin("tableExists", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.tableExists", bytes);
  }
}

void AccumuloProxyProcessor::process_tableIdMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.tableIdMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.tableIdMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.tableIdMap");
  }

  AccumuloProxy_tableIdMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.tableIdMap", bytes);
  }

  AccumuloProxy_tableIdMap_result result;
  try {
    iface_->tableIdMap(result.success, args.login);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.tableIdMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("tableIdMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.tableIdMap");
  }

  oprot->writeMessageBegin("tableIdMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.tableIdMap", bytes);
  }
}

void AccumuloProxyProcessor::process_testTableClassLoad(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.testTableClassLoad", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.testTableClassLoad");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.testTableClassLoad");
  }

  AccumuloProxy_testTableClassLoad_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.testTableClassLoad", bytes);
  }

  AccumuloProxy_testTableClassLoad_result result;
  try {
    result.success = iface_->testTableClassLoad(args.login, args.tableName, args.className, args.asTypeName);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.testTableClassLoad");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testTableClassLoad", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.testTableClassLoad");
  }

  oprot->writeMessageBegin("testTableClassLoad", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.testTableClassLoad", bytes);
  }
}

void AccumuloProxyProcessor::process_pingTabletServer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.pingTabletServer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.pingTabletServer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.pingTabletServer");
  }

  AccumuloProxy_pingTabletServer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.pingTabletServer", bytes);
  }

  AccumuloProxy_pingTabletServer_result result;
  try {
    iface_->pingTabletServer(args.login, args.tserver);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.pingTabletServer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("pingTabletServer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.pingTabletServer");
  }

  oprot->writeMessageBegin("pingTabletServer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.pingTabletServer", bytes);
  }
}

void AccumuloProxyProcessor::process_getActiveScans(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getActiveScans", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getActiveScans");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getActiveScans");
  }

  AccumuloProxy_getActiveScans_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getActiveScans", bytes);
  }

  AccumuloProxy_getActiveScans_result result;
  try {
    iface_->getActiveScans(result.success, args.login, args.tserver);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getActiveScans");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getActiveScans", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getActiveScans");
  }

  oprot->writeMessageBegin("getActiveScans", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getActiveScans", bytes);
  }
}

void AccumuloProxyProcessor::process_getActiveCompactions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getActiveCompactions", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getActiveCompactions");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getActiveCompactions");
  }

  AccumuloProxy_getActiveCompactions_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getActiveCompactions", bytes);
  }

  AccumuloProxy_getActiveCompactions_result result;
  try {
    iface_->getActiveCompactions(result.success, args.login, args.tserver);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getActiveCompactions");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getActiveCompactions", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getActiveCompactions");
  }

  oprot->writeMessageBegin("getActiveCompactions", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getActiveCompactions", bytes);
  }
}

void AccumuloProxyProcessor::process_getSiteConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getSiteConfiguration", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getSiteConfiguration");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getSiteConfiguration");
  }

  AccumuloProxy_getSiteConfiguration_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getSiteConfiguration", bytes);
  }

  AccumuloProxy_getSiteConfiguration_result result;
  try {
    iface_->getSiteConfiguration(result.success, args.login);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getSiteConfiguration");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSiteConfiguration", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getSiteConfiguration");
  }

  oprot->writeMessageBegin("getSiteConfiguration", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getSiteConfiguration", bytes);
  }
}

void AccumuloProxyProcessor::process_getSystemConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getSystemConfiguration", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getSystemConfiguration");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getSystemConfiguration");
  }

  AccumuloProxy_getSystemConfiguration_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getSystemConfiguration", bytes);
  }

  AccumuloProxy_getSystemConfiguration_result result;
  try {
    iface_->getSystemConfiguration(result.success, args.login);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getSystemConfiguration");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSystemConfiguration", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getSystemConfiguration");
  }

  oprot->writeMessageBegin("getSystemConfiguration", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getSystemConfiguration", bytes);
  }
}

void AccumuloProxyProcessor::process_getTabletServers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getTabletServers", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getTabletServers");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getTabletServers");
  }

  AccumuloProxy_getTabletServers_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getTabletServers", bytes);
  }

  AccumuloProxy_getTabletServers_result result;
  try {
    iface_->getTabletServers(result.success, args.login);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getTabletServers");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTabletServers", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getTabletServers");
  }

  oprot->writeMessageBegin("getTabletServers", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getTabletServers", bytes);
  }
}

void AccumuloProxyProcessor::process_removeProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.removeProperty", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.removeProperty");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.removeProperty");
  }

  AccumuloProxy_removeProperty_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.removeProperty", bytes);
  }

  AccumuloProxy_removeProperty_result result;
  try {
    iface_->removeProperty(args.login, args.property);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.removeProperty");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeProperty", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.removeProperty");
  }

  oprot->writeMessageBegin("removeProperty", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.removeProperty", bytes);
  }
}

void AccumuloProxyProcessor::process_setProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.setProperty", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.setProperty");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.setProperty");
  }

  AccumuloProxy_setProperty_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.setProperty", bytes);
  }

  AccumuloProxy_setProperty_result result;
  try {
    iface_->setProperty(args.login, args.property, args.value);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.setProperty");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setProperty", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.setProperty");
  }

  oprot->writeMessageBegin("setProperty", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.setProperty", bytes);
  }
}

void AccumuloProxyProcessor::process_testClassLoad(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.testClassLoad", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.testClassLoad");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.testClassLoad");
  }

  AccumuloProxy_testClassLoad_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.testClassLoad", bytes);
  }

  AccumuloProxy_testClassLoad_result result;
  try {
    result.success = iface_->testClassLoad(args.login, args.className, args.asTypeName);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.testClassLoad");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testClassLoad", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.testClassLoad");
  }

  oprot->writeMessageBegin("testClassLoad", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.testClassLoad", bytes);
  }
}

void AccumuloProxyProcessor::process_authenticateUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.authenticateUser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.authenticateUser");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.authenticateUser");
  }

  AccumuloProxy_authenticateUser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.authenticateUser", bytes);
  }

  AccumuloProxy_authenticateUser_result result;
  try {
    result.success = iface_->authenticateUser(args.login, args.user, args.properties);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.authenticateUser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("authenticateUser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.authenticateUser");
  }

  oprot->writeMessageBegin("authenticateUser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.authenticateUser", bytes);
  }
}

void AccumuloProxyProcessor::process_changeUserAuthorizations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.changeUserAuthorizations", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.changeUserAuthorizations");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.changeUserAuthorizations");
  }

  AccumuloProxy_changeUserAuthorizations_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.changeUserAuthorizations", bytes);
  }

  AccumuloProxy_changeUserAuthorizations_result result;
  try {
    iface_->changeUserAuthorizations(args.login, args.user, args.authorizations);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.changeUserAuthorizations");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("changeUserAuthorizations", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.changeUserAuthorizations");
  }

  oprot->writeMessageBegin("changeUserAuthorizations", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.changeUserAuthorizations", bytes);
  }
}

void AccumuloProxyProcessor::process_changeLocalUserPassword(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.changeLocalUserPassword", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.changeLocalUserPassword");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.changeLocalUserPassword");
  }

  AccumuloProxy_changeLocalUserPassword_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.changeLocalUserPassword", bytes);
  }

  AccumuloProxy_changeLocalUserPassword_result result;
  try {
    iface_->changeLocalUserPassword(args.login, args.user, args.password);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.changeLocalUserPassword");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("changeLocalUserPassword", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.changeLocalUserPassword");
  }

  oprot->writeMessageBegin("changeLocalUserPassword", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.changeLocalUserPassword", bytes);
  }
}

void AccumuloProxyProcessor::process_createLocalUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.createLocalUser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.createLocalUser");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.createLocalUser");
  }

  AccumuloProxy_createLocalUser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.createLocalUser", bytes);
  }

  AccumuloProxy_createLocalUser_result result;
  try {
    iface_->createLocalUser(args.login, args.user, args.password);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.createLocalUser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createLocalUser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.createLocalUser");
  }

  oprot->writeMessageBegin("createLocalUser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.createLocalUser", bytes);
  }
}

void AccumuloProxyProcessor::process_dropLocalUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.dropLocalUser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.dropLocalUser");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.dropLocalUser");
  }

  AccumuloProxy_dropLocalUser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.dropLocalUser", bytes);
  }

  AccumuloProxy_dropLocalUser_result result;
  try {
    iface_->dropLocalUser(args.login, args.user);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.dropLocalUser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("dropLocalUser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.dropLocalUser");
  }

  oprot->writeMessageBegin("dropLocalUser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.dropLocalUser", bytes);
  }
}

void AccumuloProxyProcessor::process_getUserAuthorizations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getUserAuthorizations", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getUserAuthorizations");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getUserAuthorizations");
  }

  AccumuloProxy_getUserAuthorizations_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getUserAuthorizations", bytes);
  }

  AccumuloProxy_getUserAuthorizations_result result;
  try {
    iface_->getUserAuthorizations(result.success, args.login, args.user);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getUserAuthorizations");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getUserAuthorizations", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getUserAuthorizations");
  }

  oprot->writeMessageBegin("getUserAuthorizations", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getUserAuthorizations", bytes);
  }
}

void AccumuloProxyProcessor::process_grantSystemPermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.grantSystemPermission", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.grantSystemPermission");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.grantSystemPermission");
  }

  AccumuloProxy_grantSystemPermission_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.grantSystemPermission", bytes);
  }

  AccumuloProxy_grantSystemPermission_result result;
  try {
    iface_->grantSystemPermission(args.login, args.user, args.perm);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.grantSystemPermission");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("grantSystemPermission", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.grantSystemPermission");
  }

  oprot->writeMessageBegin("grantSystemPermission", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.grantSystemPermission", bytes);
  }
}

void AccumuloProxyProcessor::process_grantTablePermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.grantTablePermission", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.grantTablePermission");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.grantTablePermission");
  }

  AccumuloProxy_grantTablePermission_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.grantTablePermission", bytes);
  }

  AccumuloProxy_grantTablePermission_result result;
  try {
    iface_->grantTablePermission(args.login, args.user, args.table, args.perm);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.grantTablePermission");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("grantTablePermission", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.grantTablePermission");
  }

  oprot->writeMessageBegin("grantTablePermission", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.grantTablePermission", bytes);
  }
}

void AccumuloProxyProcessor::process_hasSystemPermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.hasSystemPermission", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.hasSystemPermission");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.hasSystemPermission");
  }

  AccumuloProxy_hasSystemPermission_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.hasSystemPermission", bytes);
  }

  AccumuloProxy_hasSystemPermission_result result;
  try {
    result.success = iface_->hasSystemPermission(args.login, args.user, args.perm);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.hasSystemPermission");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("hasSystemPermission", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.hasSystemPermission");
  }

  oprot->writeMessageBegin("hasSystemPermission", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.hasSystemPermission", bytes);
  }
}

void AccumuloProxyProcessor::process_hasTablePermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.hasTablePermission", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.hasTablePermission");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.hasTablePermission");
  }

  AccumuloProxy_hasTablePermission_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.hasTablePermission", bytes);
  }

  AccumuloProxy_hasTablePermission_result result;
  try {
    result.success = iface_->hasTablePermission(args.login, args.user, args.table, args.perm);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.hasTablePermission");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("hasTablePermission", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.hasTablePermission");
  }

  oprot->writeMessageBegin("hasTablePermission", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.hasTablePermission", bytes);
  }
}

void AccumuloProxyProcessor::process_listLocalUsers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.listLocalUsers", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.listLocalUsers");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.listLocalUsers");
  }

  AccumuloProxy_listLocalUsers_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.listLocalUsers", bytes);
  }

  AccumuloProxy_listLocalUsers_result result;
  try {
    iface_->listLocalUsers(result.success, args.login);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.listLocalUsers");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("listLocalUsers", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.listLocalUsers");
  }

  oprot->writeMessageBegin("listLocalUsers", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.listLocalUsers", bytes);
  }
}

void AccumuloProxyProcessor::process_revokeSystemPermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.revokeSystemPermission", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.revokeSystemPermission");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.revokeSystemPermission");
  }

  AccumuloProxy_revokeSystemPermission_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.revokeSystemPermission", bytes);
  }

  AccumuloProxy_revokeSystemPermission_result result;
  try {
    iface_->revokeSystemPermission(args.login, args.user, args.perm);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.revokeSystemPermission");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("revokeSystemPermission", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.revokeSystemPermission");
  }

  oprot->writeMessageBegin("revokeSystemPermission", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.revokeSystemPermission", bytes);
  }
}

void AccumuloProxyProcessor::process_revokeTablePermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.revokeTablePermission", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.revokeTablePermission");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.revokeTablePermission");
  }

  AccumuloProxy_revokeTablePermission_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.revokeTablePermission", bytes);
  }

  AccumuloProxy_revokeTablePermission_result result;
  try {
    iface_->revokeTablePermission(args.login, args.user, args.table, args.perm);
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.revokeTablePermission");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("revokeTablePermission", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.revokeTablePermission");
  }

  oprot->writeMessageBegin("revokeTablePermission", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.revokeTablePermission", bytes);
  }
}

void AccumuloProxyProcessor::process_createBatchScanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.createBatchScanner", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.createBatchScanner");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.createBatchScanner");
  }

  AccumuloProxy_createBatchScanner_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.createBatchScanner", bytes);
  }

  AccumuloProxy_createBatchScanner_result result;
  try {
    iface_->createBatchScanner(result.success, args.login, args.tableName, args.options);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.createBatchScanner");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createBatchScanner", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.createBatchScanner");
  }

  oprot->writeMessageBegin("createBatchScanner", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.createBatchScanner", bytes);
  }
}

void AccumuloProxyProcessor::process_createScanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.createScanner", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.createScanner");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.createScanner");
  }

  AccumuloProxy_createScanner_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.createScanner", bytes);
  }

  AccumuloProxy_createScanner_result result;
  try {
    iface_->createScanner(result.success, args.login, args.tableName, args.options);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.createScanner");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createScanner", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.createScanner");
  }

  oprot->writeMessageBegin("createScanner", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.createScanner", bytes);
  }
}

void AccumuloProxyProcessor::process_hasNext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.hasNext", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.hasNext");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.hasNext");
  }

  AccumuloProxy_hasNext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.hasNext", bytes);
  }

  AccumuloProxy_hasNext_result result;
  try {
    result.success = iface_->hasNext(args.scanner);
    result.__isset.success = true;
  } catch (UnknownScanner &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.hasNext");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("hasNext", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.hasNext");
  }

  oprot->writeMessageBegin("hasNext", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.hasNext", bytes);
  }
}

void AccumuloProxyProcessor::process_nextEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.nextEntry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.nextEntry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.nextEntry");
  }

  AccumuloProxy_nextEntry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.nextEntry", bytes);
  }

  AccumuloProxy_nextEntry_result result;
  try {
    iface_->nextEntry(result.success, args.scanner);
    result.__isset.success = true;
  } catch (NoMoreEntriesException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (UnknownScanner &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (AccumuloSecurityException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.nextEntry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("nextEntry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.nextEntry");
  }

  oprot->writeMessageBegin("nextEntry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.nextEntry", bytes);
  }
}

void AccumuloProxyProcessor::process_nextK(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.nextK", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.nextK");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.nextK");
  }

  AccumuloProxy_nextK_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.nextK", bytes);
  }

  AccumuloProxy_nextK_result result;
  try {
    iface_->nextK(result.success, args.scanner, args.k);
    result.__isset.success = true;
  } catch (NoMoreEntriesException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (UnknownScanner &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (AccumuloSecurityException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.nextK");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("nextK", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.nextK");
  }

  oprot->writeMessageBegin("nextK", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.nextK", bytes);
  }
}

void AccumuloProxyProcessor::process_closeScanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.closeScanner", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.closeScanner");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.closeScanner");
  }

  AccumuloProxy_closeScanner_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.closeScanner", bytes);
  }

  AccumuloProxy_closeScanner_result result;
  try {
    iface_->closeScanner(args.scanner);
  } catch (UnknownScanner &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.closeScanner");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeScanner", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.closeScanner");
  }

  oprot->writeMessageBegin("closeScanner", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.closeScanner", bytes);
  }
}

void AccumuloProxyProcessor::process_updateAndFlush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.updateAndFlush", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.updateAndFlush");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.updateAndFlush");
  }

  AccumuloProxy_updateAndFlush_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.updateAndFlush", bytes);
  }

  AccumuloProxy_updateAndFlush_result result;
  try {
    iface_->updateAndFlush(args.login, args.tableName, args.cells);
  } catch (AccumuloException &outch1) {
    result.outch1 = outch1;
    result.__isset.outch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (MutationsRejectedException &ouch4) {
    result.ouch4 = ouch4;
    result.__isset.ouch4 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.updateAndFlush");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateAndFlush", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.updateAndFlush");
  }

  oprot->writeMessageBegin("updateAndFlush", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.updateAndFlush", bytes);
  }
}

void AccumuloProxyProcessor::process_createWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.createWriter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.createWriter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.createWriter");
  }

  AccumuloProxy_createWriter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.createWriter", bytes);
  }

  AccumuloProxy_createWriter_result result;
  try {
    iface_->createWriter(result.success, args.login, args.tableName, args.opts);
    result.__isset.success = true;
  } catch (AccumuloException &outch1) {
    result.outch1 = outch1;
    result.__isset.outch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.createWriter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createWriter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.createWriter");
  }

  oprot->writeMessageBegin("createWriter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.createWriter", bytes);
  }
}

void AccumuloProxyProcessor::process_update(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.update", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.update");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.update");
  }

  AccumuloProxy_update_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.update", bytes);
  }

  try {
    iface_->update(args.writer, args.cells);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.update");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "AccumuloProxy.update");
  }

  return;
}

void AccumuloProxyProcessor::process_flush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.flush", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.flush");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.flush");
  }

  AccumuloProxy_flush_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.flush", bytes);
  }

  AccumuloProxy_flush_result result;
  try {
    iface_->flush(args.writer);
  } catch (UnknownWriter &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (MutationsRejectedException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.flush");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("flush", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.flush");
  }

  oprot->writeMessageBegin("flush", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.flush", bytes);
  }
}

void AccumuloProxyProcessor::process_closeWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.closeWriter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.closeWriter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.closeWriter");
  }

  AccumuloProxy_closeWriter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.closeWriter", bytes);
  }

  AccumuloProxy_closeWriter_result result;
  try {
    iface_->closeWriter(args.writer);
  } catch (UnknownWriter &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (MutationsRejectedException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.closeWriter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeWriter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.closeWriter");
  }

  oprot->writeMessageBegin("closeWriter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.closeWriter", bytes);
  }
}

void AccumuloProxyProcessor::process_updateRowConditionally(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.updateRowConditionally", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.updateRowConditionally");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.updateRowConditionally");
  }

  AccumuloProxy_updateRowConditionally_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.updateRowConditionally", bytes);
  }

  AccumuloProxy_updateRowConditionally_result result;
  try {
    result.success = iface_->updateRowConditionally(args.login, args.tableName, args.row, args.updates);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.updateRowConditionally");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateRowConditionally", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.updateRowConditionally");
  }

  oprot->writeMessageBegin("updateRowConditionally", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.updateRowConditionally", bytes);
  }
}

void AccumuloProxyProcessor::process_createConditionalWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.createConditionalWriter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.createConditionalWriter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.createConditionalWriter");
  }

  AccumuloProxy_createConditionalWriter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.createConditionalWriter", bytes);
  }

  AccumuloProxy_createConditionalWriter_result result;
  try {
    iface_->createConditionalWriter(result.success, args.login, args.tableName, args.options);
    result.__isset.success = true;
  } catch (AccumuloException &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloSecurityException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (TableNotFoundException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.createConditionalWriter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createConditionalWriter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.createConditionalWriter");
  }

  oprot->writeMessageBegin("createConditionalWriter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.createConditionalWriter", bytes);
  }
}

void AccumuloProxyProcessor::process_updateRowsConditionally(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.updateRowsConditionally", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.updateRowsConditionally");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.updateRowsConditionally");
  }

  AccumuloProxy_updateRowsConditionally_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.updateRowsConditionally", bytes);
  }

  AccumuloProxy_updateRowsConditionally_result result;
  try {
    iface_->updateRowsConditionally(result.success, args.conditionalWriter, args.updates);
    result.__isset.success = true;
  } catch (UnknownWriter &ouch1) {
    result.ouch1 = ouch1;
    result.__isset.ouch1 = true;
  } catch (AccumuloException &ouch2) {
    result.ouch2 = ouch2;
    result.__isset.ouch2 = true;
  } catch (AccumuloSecurityException &ouch3) {
    result.ouch3 = ouch3;
    result.__isset.ouch3 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.updateRowsConditionally");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateRowsConditionally", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.updateRowsConditionally");
  }

  oprot->writeMessageBegin("updateRowsConditionally", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.updateRowsConditionally", bytes);
  }
}

void AccumuloProxyProcessor::process_closeConditionalWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.closeConditionalWriter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.closeConditionalWriter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.closeConditionalWriter");
  }

  AccumuloProxy_closeConditionalWriter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.closeConditionalWriter", bytes);
  }

  AccumuloProxy_closeConditionalWriter_result result;
  try {
    iface_->closeConditionalWriter(args.conditionalWriter);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.closeConditionalWriter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeConditionalWriter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.closeConditionalWriter");
  }

  oprot->writeMessageBegin("closeConditionalWriter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.closeConditionalWriter", bytes);
  }
}

void AccumuloProxyProcessor::process_getRowRange(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getRowRange", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getRowRange");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getRowRange");
  }

  AccumuloProxy_getRowRange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getRowRange", bytes);
  }

  AccumuloProxy_getRowRange_result result;
  try {
    iface_->getRowRange(result.success, args.row);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getRowRange");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRowRange", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getRowRange");
  }

  oprot->writeMessageBegin("getRowRange", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getRowRange", bytes);
  }
}

void AccumuloProxyProcessor::process_getFollowing(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("AccumuloProxy.getFollowing", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AccumuloProxy.getFollowing");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "AccumuloProxy.getFollowing");
  }

  AccumuloProxy_getFollowing_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "AccumuloProxy.getFollowing", bytes);
  }

  AccumuloProxy_getFollowing_result result;
  try {
    iface_->getFollowing(result.success, args.key, args.part);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "AccumuloProxy.getFollowing");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getFollowing", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "AccumuloProxy.getFollowing");
  }

  oprot->writeMessageBegin("getFollowing", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "AccumuloProxy.getFollowing", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > AccumuloProxyProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< AccumuloProxyIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< AccumuloProxyIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new AccumuloProxyProcessor(handler));
  return processor;
}
} // namespace

